[
    {
        "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{Decimal}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{Decimal}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
        "signature": {
            "name": "ReadAsDouble",
            "returns": "double?",
            "params": [],
            "modifier": [
                "public",
                "virtual"
            ],
            "annotations": [],
            "generics": []
        },
        "language": "csharp",
        "parent": {
            "name": "JsonReader",
            "doc": "/// <summary>\r\n/// Represents a reader that provides fast, non-cached, forward-only access to serialized JSON data.\r\n/// </summary>",
            "other_methods": [
                {
                    "doc": "",
                    "signature": {
                        "name": "GetPosition",
                        "returns": "JsonPosition",
                        "params": [
                            "int depth"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (_stack != null && depth < _stack.Count)\r\n            {\r\n                return _stack[depth];\r\n            }\r\n\r\n            return _currentPosition;\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "Push",
                        "returns": "void",
                        "params": [
                            "JsonContainerType value"
                        ],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            UpdateScopeWithFinishedValue();\r\n\r\n            if (_currentPosition.Type == JsonContainerType.None)\r\n            {\r\n                _currentPosition = new JsonPosition(value);\r\n            }\r\n            else\r\n            {\r\n                if (_stack == null)\r\n                {\r\n                    _stack = new List<JsonPosition>();\r\n                }\r\n\r\n                _stack.Add(_currentPosition);\r\n                _currentPosition = new JsonPosition(value);\r\n\r\n                // this is a little hacky because Depth increases when first property/value is written but only testing here is faster/simpler\r\n                if (_maxDepth != null && Depth + 1 > _maxDepth && !_hasExceededMaxDepth)\r\n                {\r\n                    _hasExceededMaxDepth = true;\r\n                    throw JsonReaderException.Create(this, \"The reader's MaxDepth of {0} has been exceeded.\".FormatWith(CultureInfo.InvariantCulture, _maxDepth));\r\n                }\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "Pop",
                        "returns": "JsonContainerType",
                        "params": [],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonPosition oldPosition;\r\n            if (_stack != null && _stack.Count > 0)\r\n            {\r\n                oldPosition = _currentPosition;\r\n                _currentPosition = _stack[_stack.Count - 1];\r\n                _stack.RemoveAt(_stack.Count - 1);\r\n            }\r\n            else\r\n            {\r\n                oldPosition = _currentPosition;\r\n                _currentPosition = new JsonPosition();\r\n            }\r\n\r\n            if (_maxDepth != null && Depth <= _maxDepth)\r\n            {\r\n                _hasExceededMaxDepth = false;\r\n            }\r\n\r\n            return oldPosition.Type;\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "Peek",
                        "returns": "JsonContainerType",
                        "params": [],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            return _currentPosition.Type;\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream.\r\n/// </summary>\r\n/// <returns><c>true</c> if the next token was read successfully; <c>false</c> if there are no more tokens to read.</returns>",
                    "signature": {
                        "name": "Read",
                        "returns": "bool",
                        "params": [],
                        "modifier": [
                            "public",
                            "abstract"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": ""
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{Int32}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{Int32}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsInt32",
                        "returns": "int?",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Integer:\r\n                case JsonToken.Float:\r\n                    if (!(Value is int))\r\n                    {\r\n                        SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture), false);\r\n                    }\r\n\r\n                    return (int)Value;\r\n                case JsonToken.String:\r\n                    string s = (string)Value;\r\n                    return ReadInt32String(s);\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading integer. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadInt32String",
                        "returns": "int?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            int i;\r\n            if (int.TryParse(s, NumberStyles.Integer, Culture, out i))\r\n            {\r\n                SetToken(JsonToken.Integer, i, false);\r\n                return i;\r\n            }\r\n            else\r\n            {\r\n                SetToken(JsonToken.String, s, false);\r\n                throw JsonReaderException.Create(this, \"Could not convert string to integer: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"String\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"String\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsString",
                        "returns": "string",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.String:\r\n                    return (string)Value;\r\n            }\r\n\r\n            if (JsonTokenUtils.IsPrimitiveToken(t))\r\n            {\r\n                if (Value != null)\r\n                {\r\n                    string s;\r\n                    if (Value is IFormattable)\r\n                    {\r\n                        s = ((IFormattable)Value).ToString(null, Culture);\r\n                    }\r\n                    else if (Value is Uri)\r\n                    {\r\n                        s = ((Uri)Value).OriginalString;\r\n                    }\r\n                    else\r\n                    {\r\n                        s = Value.ToString();\r\n                    }\r\n\r\n                    SetToken(JsonToken.String, s, false);\r\n                    return s;\r\n                }\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading string. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Byte\"/>[].\r\n/// </summary>\r\n/// <returns>A <see cref = \"Byte\"/>[] or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsBytes",
                        "returns": "byte[]",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            if (t == JsonToken.None)\r\n            {\r\n                return null;\r\n            }\r\n\r\n            if (TokenType == JsonToken.StartObject)\r\n            {\r\n                ReadIntoWrappedTypeObject();\r\n\r\n                byte[] data = ReadAsBytes();\r\n                ReaderReadAndAssert();\r\n\r\n                if (TokenType != JsonToken.EndObject)\r\n                {\r\n                    throw JsonReaderException.Create(this, \"Error reading bytes. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, TokenType));\r\n                }\r\n\r\n                SetToken(JsonToken.Bytes, data, false);\r\n                return data;\r\n            }\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.String:\r\n                    {\r\n                        // attempt to convert possible base 64 or GUID string to bytes\r\n                        // GUID has to have format 00000000-0000-0000-0000-000000000000\r\n                        string s = (string)Value;\r\n\r\n                        byte[] data;\r\n\r\n                        Guid g;\r\n                        if (s.Length == 0)\r\n                        {\r\n                            data = new byte[0];\r\n                        }\r\n                        else if (ConvertUtils.TryConvertGuid(s, out g))\r\n                        {\r\n                            data = g.ToByteArray();\r\n                        }\r\n                        else\r\n                        {\r\n                            data = Convert.FromBase64String(s);\r\n                        }\r\n\r\n                        SetToken(JsonToken.Bytes, data, false);\r\n                        return data;\r\n                    }\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Bytes:\r\n                    if (ValueType == typeof(Guid))\r\n                    {\r\n                        byte[] data = ((Guid)Value).ToByteArray();\r\n                        SetToken(JsonToken.Bytes, data, false);\r\n                        return data;\r\n                    }\r\n\r\n                    return (byte[])Value;\r\n                case JsonToken.StartArray:\r\n                    return ReadArrayIntoByteArray();\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading bytes. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadArrayIntoByteArray",
                        "returns": "byte[]",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            List<byte> buffer = new List<byte>();\r\n\r\n            while (true)\r\n            {\r\n                JsonToken t = GetContentToken();\r\n                switch (t)\r\n                {\r\n                    case JsonToken.None:\r\n                        throw JsonReaderException.Create(this, \"Unexpected end when reading bytes.\");\r\n                    case JsonToken.Integer:\r\n                        buffer.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));\r\n                        break;\r\n                    case JsonToken.EndArray:\r\n                        byte[] d = buffer.ToArray();\r\n                        SetToken(JsonToken.Bytes, d, false);\r\n                        return d;\r\n                    default:\r\n                        throw JsonReaderException.Create(this, \"Unexpected token when reading bytes: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n                }\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadDoubleString",
                        "returns": "double?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            double d;\r\n            if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, Culture, out d))\r\n            {\r\n                SetToken(JsonToken.Float, d, false);\r\n                return d;\r\n            }\r\n            else\r\n            {\r\n                SetToken(JsonToken.String, s, false);\r\n                throw JsonReaderException.Create(this, \"Could not convert string to double: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{Boolean}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{Boolean}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsBoolean",
                        "returns": "bool?",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Integer:\r\n                case JsonToken.Float:\r\n                    bool b;\r\n#if !(NET20 || NET35 || PORTABLE40 || PORTABLE) || NETSTANDARD1_1\r\n                    if (Value is BigInteger)\r\n                    {\r\n                        b = (BigInteger)Value != 0;\r\n                    }\r\n                    else\r\n#endif\r\n                    {\r\n                        b = Convert.ToBoolean(Value, CultureInfo.InvariantCulture);\r\n                    }\r\n\r\n                    SetToken(JsonToken.Boolean, b, false);\r\n\r\n                    return b;\r\n                case JsonToken.String:\r\n                    return ReadBooleanString((string)Value);\r\n                case JsonToken.Boolean:\r\n                    return (bool)Value;\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading boolean. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadBooleanString",
                        "returns": "bool?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            bool b;\r\n            if (bool.TryParse(s, out b))\r\n            {\r\n                SetToken(JsonToken.Boolean, b, false);\r\n                return b;\r\n            }\r\n            else\r\n            {\r\n                SetToken(JsonToken.String, s, false);\r\n                throw JsonReaderException.Create(this, \"Could not convert string to boolean: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{Decimal}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{Decimal}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsDecimal",
                        "returns": "decimal?",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Integer:\r\n                case JsonToken.Float:\r\n                    if (!(Value is decimal))\r\n                    {\r\n                        SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture), false);\r\n                    }\r\n\r\n                    return (decimal)Value;\r\n                case JsonToken.String:\r\n                    return ReadDecimalString((string)Value);\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading decimal. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadDecimalString",
                        "returns": "decimal?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            decimal d;\r\n            if (decimal.TryParse(s, NumberStyles.Number, Culture, out d))\r\n            {\r\n                SetToken(JsonToken.Float, d, false);\r\n                return d;\r\n            }\r\n            else\r\n            {\r\n                SetToken(JsonToken.String, s, false);\r\n                throw JsonReaderException.Create(this, \"Could not convert string to decimal: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{DateTime}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{DateTime}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsDateTime",
                        "returns": "DateTime?",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            switch (GetContentToken())\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Date:\r\n#if !NET20\r\n                    if (Value is DateTimeOffset)\r\n                    {\r\n                        SetToken(JsonToken.Date, ((DateTimeOffset)Value).DateTime, false);\r\n                    }\r\n#endif\r\n\r\n                    return (DateTime)Value;\r\n                case JsonToken.String:\r\n                    string s = (string)Value;\r\n                    return ReadDateTimeString(s);\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading date. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, TokenType));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadDateTimeString",
                        "returns": "DateTime?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            DateTime dt;\r\n            if (DateTimeUtils.TryParseDateTime(s, DateTimeZoneHandling, _dateFormatString, Culture, out dt))\r\n            {\r\n                dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);\r\n                SetToken(JsonToken.Date, dt, false);\r\n                return dt;\r\n            }\r\n\r\n            if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))\r\n            {\r\n                dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);\r\n                SetToken(JsonToken.Date, dt, false);\r\n                return dt;\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Could not convert string to DateTime: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Reads the next JSON token from the stream as a <see cref = \"Nullable{DateTimeOffset}\"/>.\r\n/// </summary>\r\n/// <returns>A <see cref = \"Nullable{DateTimeOffset}\"/>. This method will return <c>null</c> at the end of an array.</returns>",
                    "signature": {
                        "name": "ReadAsDateTimeOffset",
                        "returns": "DateTimeOffset?",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Date:\r\n                    if (Value is DateTime)\r\n                    {\r\n                        SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value), false);\r\n                    }\r\n\r\n                    return (DateTimeOffset)Value;\r\n                case JsonToken.String:\r\n                    string s = (string)Value;\r\n                    return ReadDateTimeOffsetString(s);\r\n                default:\r\n                    throw JsonReaderException.Create(this, \"Error reading date. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadDateTimeOffsetString",
                        "returns": "DateTimeOffset?",
                        "params": [
                            "string s"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (string.IsNullOrEmpty(s))\r\n            {\r\n                SetToken(JsonToken.Null, null, false);\r\n                return null;\r\n            }\r\n\r\n            DateTimeOffset dt;\r\n            if (DateTimeUtils.TryParseDateTimeOffset(s, _dateFormatString, Culture, out dt))\r\n            {\r\n                SetToken(JsonToken.Date, dt, false);\r\n                return dt;\r\n            }\r\n\r\n            if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))\r\n            {\r\n                SetToken(JsonToken.Date, dt, false);\r\n                return dt;\r\n            }\r\n\r\n            SetToken(JsonToken.String, s, false);\r\n            throw JsonReaderException.Create(this, \"Could not convert string to DateTimeOffset: {0}.\".FormatWith(CultureInfo.InvariantCulture, s));\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReaderReadAndAssert",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (!Read())\r\n            {\r\n                throw CreateUnexpectedEndException();\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "CreateUnexpectedEndException",
                        "returns": "JsonReaderException",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            return JsonReaderException.Create(this, \"Unexpected end when reading JSON.\");\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadIntoWrappedTypeObject",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            ReaderReadAndAssert();\r\n            if (Value != null && Value.ToString() == JsonTypeReflector.TypePropertyName)\r\n            {\r\n                ReaderReadAndAssert();\r\n                if (Value != null && Value.ToString().StartsWith(\"System.Byte[]\", StringComparison.Ordinal))\r\n                {\r\n                    ReaderReadAndAssert();\r\n                    if (Value.ToString() == JsonTypeReflector.ValuePropertyName)\r\n                    {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading bytes. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Skips the children of the current token.\r\n/// </summary>",
                    "signature": {
                        "name": "Skip",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "public"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (TokenType == JsonToken.PropertyName)\r\n            {\r\n                Read();\r\n            }\r\n\r\n            if (JsonTokenUtils.IsStartToken(TokenType))\r\n            {\r\n                int depth = Depth;\r\n\r\n                while (Read() && (depth < Depth))\r\n                {\r\n                }\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Sets the current token.\r\n/// </summary>\r\n/// <param name = \"newToken\">The new token.</param>",
                    "signature": {
                        "name": "SetToken",
                        "returns": "void",
                        "params": [
                            "JsonToken newToken"
                        ],
                        "modifier": [
                            "protected"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            SetToken(newToken, null, true);\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Sets the current token and value.\r\n/// </summary>\r\n/// <param name = \"newToken\">The new token.</param>\r\n/// <param name = \"value\">The value.</param>",
                    "signature": {
                        "name": "SetToken",
                        "returns": "void",
                        "params": [
                            "JsonToken newToken",
                            "object value"
                        ],
                        "modifier": [
                            "protected"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            SetToken(newToken, value, true);\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "SetToken",
                        "returns": "void",
                        "params": [
                            "JsonToken newToken",
                            "object value",
                            "bool updateIndex"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            _tokenType = newToken;\r\n            _value = value;\r\n\r\n            switch (newToken)\r\n            {\r\n                case JsonToken.StartObject:\r\n                    _currentState = State.ObjectStart;\r\n                    Push(JsonContainerType.Object);\r\n                    break;\r\n                case JsonToken.StartArray:\r\n                    _currentState = State.ArrayStart;\r\n                    Push(JsonContainerType.Array);\r\n                    break;\r\n                case JsonToken.StartConstructor:\r\n                    _currentState = State.ConstructorStart;\r\n                    Push(JsonContainerType.Constructor);\r\n                    break;\r\n                case JsonToken.EndObject:\r\n                    ValidateEnd(JsonToken.EndObject);\r\n                    break;\r\n                case JsonToken.EndArray:\r\n                    ValidateEnd(JsonToken.EndArray);\r\n                    break;\r\n                case JsonToken.EndConstructor:\r\n                    ValidateEnd(JsonToken.EndConstructor);\r\n                    break;\r\n                case JsonToken.PropertyName:\r\n                    _currentState = State.Property;\r\n\r\n                    _currentPosition.PropertyName = (string)value;\r\n                    break;\r\n                case JsonToken.Undefined:\r\n                case JsonToken.Integer:\r\n                case JsonToken.Float:\r\n                case JsonToken.Boolean:\r\n                case JsonToken.Null:\r\n                case JsonToken.Date:\r\n                case JsonToken.String:\r\n                case JsonToken.Raw:\r\n                case JsonToken.Bytes:\r\n                    SetPostValueState(updateIndex);\r\n                    break;\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "SetPostValueState",
                        "returns": "void",
                        "params": [
                            "bool updateIndex"
                        ],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (Peek() != JsonContainerType.None)\r\n            {\r\n                _currentState = State.PostValue;\r\n            }\r\n            else\r\n            {\r\n                SetFinished();\r\n            }\r\n\r\n            if (updateIndex)\r\n            {\r\n                UpdateScopeWithFinishedValue();\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "UpdateScopeWithFinishedValue",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (_currentPosition.HasIndex)\r\n            {\r\n                _currentPosition.Position++;\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ValidateEnd",
                        "returns": "void",
                        "params": [
                            "JsonToken endToken"
                        ],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonContainerType currentObject = Pop();\r\n\r\n            if (GetTypeForCloseToken(endToken) != currentObject)\r\n            {\r\n                throw JsonReaderException.Create(this, \"JsonToken {0} is not valid for closing JsonType {1}.\".FormatWith(CultureInfo.InvariantCulture, endToken, currentObject));\r\n            }\r\n\r\n            if (Peek() != JsonContainerType.None)\r\n            {\r\n                _currentState = State.PostValue;\r\n            }\r\n            else\r\n            {\r\n                SetFinished();\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Sets the state based on current token type.\r\n/// </summary>",
                    "signature": {
                        "name": "SetStateBasedOnCurrent",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "protected"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonContainerType currentObject = Peek();\r\n\r\n            switch (currentObject)\r\n            {\r\n                case JsonContainerType.Object:\r\n                    _currentState = State.Object;\r\n                    break;\r\n                case JsonContainerType.Array:\r\n                    _currentState = State.Array;\r\n                    break;\r\n                case JsonContainerType.Constructor:\r\n                    _currentState = State.Constructor;\r\n                    break;\r\n                case JsonContainerType.None:\r\n                    SetFinished();\r\n                    break;\r\n                default:\r\n                    throw JsonReaderException.Create(this, \"While setting the reader state back to current object an unexpected JsonType was encountered: {0}\".FormatWith(CultureInfo.InvariantCulture, currentObject));\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "SetFinished",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (SupportMultipleContent)\r\n            {\r\n                _currentState = State.Start;\r\n            }\r\n            else\r\n            {\r\n                _currentState = State.Finished;\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "GetTypeForCloseToken",
                        "returns": "JsonContainerType",
                        "params": [
                            "JsonToken token"
                        ],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            switch (token)\r\n            {\r\n                case JsonToken.EndObject:\r\n                    return JsonContainerType.Object;\r\n                case JsonToken.EndArray:\r\n                    return JsonContainerType.Array;\r\n                case JsonToken.EndConstructor:\r\n                    return JsonContainerType.Constructor;\r\n                default:\r\n                    throw JsonReaderException.Create(this, \"Not a valid close JsonToken: {0}\".FormatWith(CultureInfo.InvariantCulture, token));\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\r\n/// </summary>",
                    "signature": {
                        "name": "Dispose",
                        "returns": "void",
                        "params": [],
                        "modifier": [],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            Dispose(true);\r\n            GC.SuppressFinalize(this);\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Releases unmanaged and - optionally - managed resources.\r\n/// </summary>\r\n/// <param name = \"disposing\"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>",
                    "signature": {
                        "name": "Dispose",
                        "returns": "void",
                        "params": [
                            "bool disposing"
                        ],
                        "modifier": [
                            "protected",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (_currentState != State.Closed && disposing)\r\n            {\r\n                Close();\r\n            }\r\n        }"
                },
                {
                    "doc": "/// <summary>\r\n/// Changes the <see cref = \"State\"/> to Closed. \r\n/// </summary>",
                    "signature": {
                        "name": "Close",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "public",
                            "virtual"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            _currentState = State.Closed;\r\n            _tokenType = JsonToken.None;\r\n            _value = null;\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadAndAssert",
                        "returns": "void",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            if (!Read())\r\n            {\r\n                throw JsonSerializationException.Create(this, \"Unexpected end when reading JSON.\");\r\n            }\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "ReadAndMoveToContent",
                        "returns": "bool",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            return Read() && MoveToContent();\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "MoveToContent",
                        "returns": "bool",
                        "params": [],
                        "modifier": [
                            "internal"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t = TokenType;\r\n            while (t == JsonToken.None || t == JsonToken.Comment)\r\n            {\r\n                if (!Read())\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                t = TokenType;\r\n            }\r\n\r\n            return true;\r\n        }"
                },
                {
                    "doc": "",
                    "signature": {
                        "name": "GetContentToken",
                        "returns": "JsonToken",
                        "params": [],
                        "modifier": [
                            "private"
                        ],
                        "annotations": [],
                        "generics": []
                    },
                    "code": "{\r\n            JsonToken t;\r\n            do\r\n            {\r\n                if (!Read())\r\n                {\r\n                    SetToken(JsonToken.None);\r\n                    return JsonToken.None;\r\n                }\r\n                else\r\n                {\r\n                    t = TokenType;\r\n                }\r\n            } while (t == JsonToken.Comment);\r\n\r\n            return t;\r\n        }"
                }
            ],
            "variables": [
                "// current Token data\r\nprivate JsonToken _tokenType;",
                "private object _value;",
                "internal char _quoteChar;",
                "internal State _currentState;",
                "private JsonPosition _currentPosition;",
                "private CultureInfo _culture;",
                "private DateTimeZoneHandling _dateTimeZoneHandling;",
                "private int? _maxDepth;",
                "private bool _hasExceededMaxDepth;",
                "internal DateParseHandling _dateParseHandling;",
                "internal FloatParseHandling _floatParseHandling;",
                "private string _dateFormatString;",
                "private List<JsonPosition> _stack;"
            ],
            "generics": [],
            "imports": [
                "using System;",
                "using System.Collections.Generic;",
                "using System.IO;",
                "using System.Globalization;",
                "using System.Numerics;",
                "using Newtonsoft.Json.Serialization;",
                "using Newtonsoft.Json.Utilities;",
                "using System.Linq;"
            ],
            "constructors": [
                "/// <summary>\r\n/// Initializes a new instance of the <see cref = \"JsonReader\"/> class.\r\n/// </summary>\r\nprotected JsonReader()\r\n{\r\n    _currentState = State.Start;\r\n    _dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;\r\n    _dateParseHandling = DateParseHandling.DateTime;\r\n    _floatParseHandling = FloatParseHandling.Double;\r\n    CloseInput = true;\r\n}"
            ],
            "extends": "IDisposable",
            "implements": [],
            "namespace": "Newtonsoft.Json"
        },
        "code": "{\r\n            JsonToken t = GetContentToken();\r\n\r\n            switch (t)\r\n            {\r\n                case JsonToken.None:\r\n                case JsonToken.Null:\r\n                case JsonToken.EndArray:\r\n                    return null;\r\n                case JsonToken.Integer:\r\n                case JsonToken.Float:\r\n                    if (!(Value is double))\r\n                    {\r\n                        double d;\r\n#if !(NET20 || NET35 || PORTABLE40 || PORTABLE) || NETSTANDARD1_1\r\n                        if (Value is BigInteger)\r\n                        {\r\n                            d = (double)(BigInteger)Value;\r\n                        }\r\n                        else\r\n#endif\r\n                        {\r\n                            d = Convert.ToDouble(Value, CultureInfo.InvariantCulture);\r\n                        }\r\n\r\n                        SetToken(JsonToken.Float, d, false);\r\n                    }\r\n\r\n                    return (double)Value;\r\n                case JsonToken.String:\r\n                    return ReadDoubleString((string)Value);\r\n            }\r\n\r\n            throw JsonReaderException.Create(this, \"Error reading double. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\r\n        }",
        "code_file_path": "Newtonsoft.Json/JsonReader.cs",
        "called_functions": [
            "GetContentToken()",
            "Convert.ToDouble(Value, CultureInfo.InvariantCulture)",
            "SetToken(JsonToken.Float, d, false)",
            "ReadDoubleString((string)Value)",
            "JsonReaderException.Create(this, \"Error reading double. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t))",
            "\"Error reading double. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t)"
        ],
        "id": 287,
        "tests": [
            {
                "tests": "#region License\r\n// Copyright (c) 2007 James Newton-King\r\n//\r\n// Permission is hereby granted, free of charge, to any person\r\n// obtaining a copy of this software and associated documentation\r\n// files (the \"Software\"), to deal in the Software without\r\n// restriction, including without limitation the rights to use,\r\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the\r\n// Software is furnished to do so, subject to the following\r\n// conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n// OTHER DEALINGS IN THE SOFTWARE.\r\n#endregion\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n#if DNXCORE50\r\nusing Xunit;\r\nusing Test = Xunit.FactAttribute;\r\nusing Assert = Newtonsoft.Json.Tests.XUnitAssert;\r\n#else\r\nusing NUnit.Framework;\r\n#endif\r\nusing Newtonsoft.Json;\r\nusing System.IO;\r\n#if !(NET20 || NET35 || PORTABLE40 || PORTABLE) || NETSTANDARD1_1\r\nusing System.Numerics;\r\n#endif\r\nusing Newtonsoft.Json.Linq;\r\nusing Newtonsoft.Json.Tests.Serialization;\r\nusing Newtonsoft.Json.Tests.TestObjects;\r\n\r\nnamespace Newtonsoft.Json.Tests.Linq\r\n{\r\n    [TestFixture]\r\n    public class JTokenReaderTest : TestFixtureBase\r\n    {\r\n#if !(NET20 || NET35 || PORTABLE40 || PORTABLE) || NETSTANDARD1_1\r\n        [Test]\r\n        public void ConvertBigIntegerToDouble()\r\n        {\r\n            var jObject = JObject.Parse(\"{ maxValue:10000000000000000000}\");\r\n\r\n            JsonReader reader = jObject.CreateReader();\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(10000000000000000000d, reader.ReadAsDouble());\r\n            Assert.IsTrue(reader.Read());\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void ErrorTokenIndex()\r\n        {\r\n            JObject json = JObject.Parse(@\"{\"\"IntList\"\":[1, \"\"two\"\"]}\");\r\n\r\n            ExceptionAssert.Throws<Exception>(() =>\r\n            {\r\n                JsonSerializer serializer = new JsonSerializer();\r\n\r\n                serializer.Deserialize<TraceTestObject>(json.CreateReader());\r\n            }, \"Could not convert string to integer: two. Path 'IntList[1]', line 1, position 20.\");\r\n        }\r\n\r\n#if !NET20\r\n        [Test]\r\n        public void YahooFinance()\r\n        {\r\n            JObject o =\r\n                new JObject(\r\n                    new JProperty(\"Test1\", new DateTime(2000, 10, 15, 5, 5, 5, DateTimeKind.Utc)),\r\n                    new JProperty(\"Test2\", new DateTimeOffset(2000, 10, 15, 5, 5, 5, new TimeSpan(11, 11, 0))),\r\n                    new JProperty(\"Test3\", \"Test3Value\"),\r\n                    new JProperty(\"Test4\", null)\r\n                    );\r\n\r\n            using (JTokenReader jsonReader = new JTokenReader(o))\r\n            {\r\n                IJsonLineInfo lineInfo = jsonReader;\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.StartObject, jsonReader.TokenType);\r\n                Assert.AreEqual(false, lineInfo.HasLineInfo());\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test1\", jsonReader.Value);\r\n                Assert.AreEqual(false, lineInfo.HasLineInfo());\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.Date, jsonReader.TokenType);\r\n                Assert.AreEqual(new DateTime(2000, 10, 15, 5, 5, 5, DateTimeKind.Utc), jsonReader.Value);\r\n                Assert.AreEqual(false, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(0, lineInfo.LinePosition);\r\n                Assert.AreEqual(0, lineInfo.LineNumber);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test2\", jsonReader.Value);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.Date, jsonReader.TokenType);\r\n                Assert.AreEqual(new DateTimeOffset(2000, 10, 15, 5, 5, 5, new TimeSpan(11, 11, 0)), jsonReader.Value);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test3\", jsonReader.Value);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.String, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test3Value\", jsonReader.Value);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test4\", jsonReader.Value);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.Null, jsonReader.TokenType);\r\n                Assert.AreEqual(null, jsonReader.Value);\r\n\r\n                Assert.IsTrue(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.EndObject, jsonReader.TokenType);\r\n\r\n                Assert.IsFalse(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.None, jsonReader.TokenType);\r\n            }\r\n\r\n            using (JsonReader jsonReader = new JTokenReader(o.Property(\"Test2\")))\r\n            {\r\n                Assert.IsTrue(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test2\", jsonReader.Value);\r\n\r\n                Assert.IsTrue(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.Date, jsonReader.TokenType);\r\n                Assert.AreEqual(new DateTimeOffset(2000, 10, 15, 5, 5, 5, new TimeSpan(11, 11, 0)), jsonReader.Value);\r\n\r\n                Assert.IsFalse(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.None, jsonReader.TokenType);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTimeOffsetBadString()\r\n        {\r\n            string json = @\"{\"\"Offset\"\":\"\"blablahbla\"\"}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsDateTimeOffset(); }, \"Could not convert string to DateTimeOffset: blablahbla. Path 'Offset', line 1, position 22.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTimeOffsetBoolean()\r\n        {\r\n            string json = @\"{\"\"Offset\"\":true}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsDateTimeOffset(); }, \"Error reading date. Unexpected token: Boolean. Path 'Offset', line 1, position 14.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTimeOffsetString()\r\n        {\r\n            string json = @\"{\"\"Offset\"\":\"\"2012-01-24T03:50Z\"\"}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            reader.ReadAsDateTimeOffset();\r\n            Assert.AreEqual(JsonToken.Date, reader.TokenType);\r\n            Assert.AreEqual(typeof(DateTimeOffset), reader.ValueType);\r\n            Assert.AreEqual(new DateTimeOffset(2012, 1, 24, 3, 50, 0, TimeSpan.Zero), reader.Value);\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void ReadLineInfo()\r\n        {\r\n            string input = @\"{\r\n  CPU: 'Intel',\r\n  Drives: [\r\n    'DVD read/writer',\r\n    \"\"500 gigabyte hard drive\"\"\r\n  ]\r\n}\";\r\n\r\n            JObject o = JObject.Parse(input);\r\n\r\n            using (JTokenReader jsonReader = new JTokenReader(o))\r\n            {\r\n                IJsonLineInfo lineInfo = jsonReader;\r\n\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.None);\r\n                Assert.AreEqual(0, lineInfo.LineNumber);\r\n                Assert.AreEqual(0, lineInfo.LinePosition);\r\n                Assert.AreEqual(false, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(null, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.StartObject);\r\n                Assert.AreEqual(1, lineInfo.LineNumber);\r\n                Assert.AreEqual(1, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.PropertyName);\r\n                Assert.AreEqual(jsonReader.Value, \"CPU\");\r\n                Assert.AreEqual(2, lineInfo.LineNumber);\r\n                Assert.AreEqual(6, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o.Property(\"CPU\"), jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.String);\r\n                Assert.AreEqual(jsonReader.Value, \"Intel\");\r\n                Assert.AreEqual(2, lineInfo.LineNumber);\r\n                Assert.AreEqual(14, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o.Property(\"CPU\").Value, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.PropertyName);\r\n                Assert.AreEqual(jsonReader.Value, \"Drives\");\r\n                Assert.AreEqual(3, lineInfo.LineNumber);\r\n                Assert.AreEqual(9, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o.Property(\"Drives\"), jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.StartArray);\r\n                Assert.AreEqual(3, lineInfo.LineNumber);\r\n                Assert.AreEqual(11, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o.Property(\"Drives\").Value, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.String);\r\n                Assert.AreEqual(jsonReader.Value, \"DVD read/writer\");\r\n                Assert.AreEqual(4, lineInfo.LineNumber);\r\n                Assert.AreEqual(21, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o[\"Drives\"][0], jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.String);\r\n                Assert.AreEqual(jsonReader.Value, \"500 gigabyte hard drive\");\r\n                Assert.AreEqual(5, lineInfo.LineNumber);\r\n                Assert.AreEqual(29, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o[\"Drives\"][1], jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.EndArray);\r\n                Assert.AreEqual(3, lineInfo.LineNumber);\r\n                Assert.AreEqual(11, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o[\"Drives\"], jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.EndObject);\r\n                Assert.AreEqual(1, lineInfo.LineNumber);\r\n                Assert.AreEqual(1, lineInfo.LinePosition);\r\n                Assert.AreEqual(true, lineInfo.HasLineInfo());\r\n                Assert.AreEqual(o, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.None);\r\n                Assert.AreEqual(null, jsonReader.CurrentToken);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(jsonReader.TokenType, JsonToken.None);\r\n                Assert.AreEqual(null, jsonReader.CurrentToken);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void ReadBytes()\r\n        {\r\n            byte[] data = Encoding.UTF8.GetBytes(\"Hello world!\");\r\n\r\n            JObject o =\r\n                new JObject(\r\n                    new JProperty(\"Test1\", data)\r\n                    );\r\n\r\n            using (JTokenReader jsonReader = new JTokenReader(o))\r\n            {\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.StartObject, jsonReader.TokenType);\r\n\r\n                jsonReader.Read();\r\n                Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                Assert.AreEqual(\"Test1\", jsonReader.Value);\r\n\r\n                byte[] readBytes = jsonReader.ReadAsBytes();\r\n                Assert.AreEqual(data, readBytes);\r\n\r\n                Assert.IsTrue(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.EndObject, jsonReader.TokenType);\r\n\r\n                Assert.IsFalse(jsonReader.Read());\r\n                Assert.AreEqual(JsonToken.None, jsonReader.TokenType);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void ReadBytesFailure()\r\n        {\r\n            ExceptionAssert.Throws<JsonReaderException>(() =>\r\n            {\r\n                JObject o =\r\n                    new JObject(\r\n                        new JProperty(\"Test1\", 1)\r\n                        );\r\n\r\n                using (JTokenReader jsonReader = new JTokenReader(o))\r\n                {\r\n                    jsonReader.Read();\r\n                    Assert.AreEqual(JsonToken.StartObject, jsonReader.TokenType);\r\n\r\n                    jsonReader.Read();\r\n                    Assert.AreEqual(JsonToken.PropertyName, jsonReader.TokenType);\r\n                    Assert.AreEqual(\"Test1\", jsonReader.Value);\r\n\r\n                    jsonReader.ReadAsBytes();\r\n                }\r\n            }, \"Error reading bytes. Unexpected token: Integer. Path 'Test1'.\");\r\n        }\r\n\r\n        public class HasBytes\r\n        {\r\n            public byte[] Bytes { get; set; }\r\n        }\r\n\r\n        [Test]\r\n        public void ReadBytesFromString()\r\n        {\r\n            var bytes = new HasBytes { Bytes = new byte[] { 1, 2, 3, 4 } };\r\n            var json = JsonConvert.SerializeObject(bytes);\r\n\r\n            TextReader textReader = new StringReader(json);\r\n            JsonReader jsonReader = new JsonTextReader(textReader);\r\n\r\n            var jToken = JToken.ReadFrom(jsonReader);\r\n\r\n            jsonReader = new JTokenReader(jToken);\r\n\r\n            var result2 = (HasBytes)JsonSerializer.Create(null)\r\n                .Deserialize(jsonReader, typeof(HasBytes));\r\n\r\n            CollectionAssert.AreEqual(new byte[] { 1, 2, 3, 4 }, result2.Bytes);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadBytesFromEmptyString()\r\n        {\r\n            var bytes = new HasBytes { Bytes = new byte[0] };\r\n            var json = JsonConvert.SerializeObject(bytes);\r\n\r\n            TextReader textReader = new StringReader(json);\r\n            JsonReader jsonReader = new JsonTextReader(textReader);\r\n\r\n            var jToken = JToken.ReadFrom(jsonReader);\r\n\r\n            jsonReader = new JTokenReader(jToken);\r\n\r\n            var result2 = (HasBytes)JsonSerializer.Create(null)\r\n                .Deserialize(jsonReader, typeof(HasBytes));\r\n\r\n            CollectionAssert.AreEquivalent(new byte[0], result2.Bytes);\r\n        }\r\n\r\n        public class ReadAsBytesTestObject\r\n        {\r\n            public byte[] Data;\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBytesNull()\r\n        {\r\n            JsonSerializer s = new JsonSerializer();\r\n\r\n            JToken nullToken = JToken.ReadFrom(new JsonTextReader(new StringReader(\"{ Data: null }\")));\r\n            ReadAsBytesTestObject x = s.Deserialize<ReadAsBytesTestObject>(new JTokenReader(nullToken));\r\n            Assert.IsNull(x.Data);\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeByteArrayWithTypeNameHandling()\r\n        {\r\n            TestObject test = new TestObject(\"Test\", new byte[] { 72, 63, 62, 71, 92, 55 });\r\n\r\n            string json = JsonConvert.SerializeObject(test, Formatting.Indented, new JsonSerializerSettings\r\n            {\r\n                TypeNameHandling = TypeNameHandling.All\r\n            });\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonSerializer serializer = new JsonSerializer();\r\n            serializer.TypeNameHandling = TypeNameHandling.All;\r\n\r\n            using (JsonReader nodeReader = o.CreateReader())\r\n            {\r\n                // Get exception here\r\n                TestObject newObject = (TestObject)serializer.Deserialize(nodeReader);\r\n\r\n                Assert.AreEqual(\"Test\", newObject.Name);\r\n                CollectionAssert.AreEquivalent(new byte[] { 72, 63, 62, 71, 92, 55 }, newObject.Data);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeStringInt()\r\n        {\r\n            string json = @\"{\r\n  \"\"PreProperty\"\": \"\"99\"\",\r\n  \"\"PostProperty\"\": \"\"-1\"\"\r\n}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonSerializer serializer = new JsonSerializer();\r\n\r\n            using (JsonReader nodeReader = o.CreateReader())\r\n            {\r\n                MyClass c = serializer.Deserialize<MyClass>(nodeReader);\r\n\r\n                Assert.AreEqual(99, c.PreProperty);\r\n                Assert.AreEqual(-1, c.PostProperty);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDecimalInt()\r\n        {\r\n            string json = @\"{\"\"Name\"\":1}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            reader.ReadAsDecimal();\r\n            Assert.AreEqual(JsonToken.Float, reader.TokenType);\r\n            Assert.AreEqual(typeof(decimal), reader.ValueType);\r\n            Assert.AreEqual(1m, reader.Value);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsInt32Int()\r\n        {\r\n            string json = @\"{\"\"Name\"\":1}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JTokenReader reader = (JTokenReader)o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n            Assert.AreEqual(o, reader.CurrentToken);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n            Assert.AreEqual(o.Property(\"Name\"), reader.CurrentToken);\r\n\r\n            reader.ReadAsInt32();\r\n            Assert.AreEqual(o[\"Name\"], reader.CurrentToken);\r\n            Assert.AreEqual(JsonToken.Integer, reader.TokenType);\r\n            Assert.AreEqual(typeof(int), reader.ValueType);\r\n            Assert.AreEqual(1, reader.Value);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsInt32BadString()\r\n        {\r\n            string json = @\"{\"\"Name\"\":\"\"hi\"\"}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsInt32(); }, \"Could not convert string to integer: hi. Path 'Name', line 1, position 12.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsInt32Boolean()\r\n        {\r\n            string json = @\"{\"\"Name\"\":true}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsInt32(); }, \"Error reading integer. Unexpected token: Boolean. Path 'Name', line 1, position 12.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDecimalString()\r\n        {\r\n            string json = @\"{\"\"Name\"\":\"\"1.1\"\"}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            reader.ReadAsDecimal();\r\n            Assert.AreEqual(JsonToken.Float, reader.TokenType);\r\n            Assert.AreEqual(typeof(decimal), reader.ValueType);\r\n            Assert.AreEqual(1.1m, reader.Value);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDecimalBadString()\r\n        {\r\n            string json = @\"{\"\"Name\"\":\"\"blah\"\"}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsDecimal(); }, \"Could not convert string to decimal: blah. Path 'Name', line 1, position 14.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDecimalBoolean()\r\n        {\r\n            string json = @\"{\"\"Name\"\":true}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(() => { reader.ReadAsDecimal(); }, \"Error reading decimal. Unexpected token: Boolean. Path 'Name', line 1, position 12.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDecimalNull()\r\n        {\r\n            string json = @\"{\"\"Name\"\":null}\";\r\n\r\n            JObject o = JObject.Parse(json);\r\n\r\n            JsonReader reader = o.CreateReader();\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.StartObject, reader.TokenType);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(JsonToken.PropertyName, reader.TokenType);\r\n\r\n            reader.ReadAsDecimal();\r\n            Assert.AreEqual(JsonToken.Null, reader.TokenType);\r\n            Assert.AreEqual(null, reader.ValueType);\r\n            Assert.AreEqual(null, reader.Value);\r\n        }\r\n\r\n        [Test]\r\n        public void InitialPath_PropertyBase_PropertyToken()\r\n        {\r\n            JObject o = new JObject\r\n            {\r\n                { \"prop1\", true }\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(o, \"baseprop\");\r\n\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop.prop1\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop.prop1\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsFalse(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n        }\r\n\r\n        [Test]\r\n        public void InitialPath_ArrayBase_PropertyToken()\r\n        {\r\n            JObject o = new JObject\r\n            {\r\n                { \"prop1\", true }\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(o, \"[0]\");\r\n\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0].prop1\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0].prop1\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsFalse(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n        }\r\n\r\n        [Test]\r\n        public void InitialPath_PropertyBase_ArrayToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a, \"baseprop\");\r\n\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop[0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop[1]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n\r\n            Assert.IsFalse(reader.Read());\r\n            Assert.AreEqual(\"baseprop\", reader.Path);\r\n        }\r\n\r\n        [Test]\r\n        public void InitialPath_ArrayBase_ArrayToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a, \"[0]\");\r\n\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0][0]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0][1]\", reader.Path);\r\n\r\n            Assert.IsTrue(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n\r\n            Assert.IsFalse(reader.Read());\r\n            Assert.AreEqual(\"[0]\", reader.Path);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDouble_InvalidToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(\r\n                () => { reader.ReadAsDouble(); },\r\n                \"Error reading double. Unexpected token: StartArray. Path ''.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBoolean_InvalidToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(\r\n                () => { reader.ReadAsBoolean(); },\r\n                \"Error reading boolean. Unexpected token: StartArray. Path ''.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTime_InvalidToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(\r\n                () => { reader.ReadAsDateTime(); },\r\n                \"Error reading date. Unexpected token: StartArray. Path ''.\");\r\n        }\r\n\r\n#if !NET20\r\n        [Test]\r\n        public void ReadAsDateTimeOffset_InvalidToken()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a);\r\n\r\n            ExceptionAssert.Throws<JsonReaderException>(\r\n                () => { reader.ReadAsDateTimeOffset(); },\r\n                \"Error reading date. Unexpected token: StartArray. Path ''.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTimeOffset_DateTime()\r\n        {\r\n            JValue v = new JValue(new DateTime(2001, 12, 12, 12, 12, 12, DateTimeKind.Utc));\r\n\r\n            JTokenReader reader = new JTokenReader(v);\r\n\r\n            Assert.AreEqual(new DateTimeOffset(2001, 12, 12, 12, 12, 12, TimeSpan.Zero), reader.ReadAsDateTimeOffset());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTimeOffset_String()\r\n        {\r\n            JValue v = new JValue(\"2012-01-24T03:50Z\");\r\n\r\n            JTokenReader reader = new JTokenReader(v);\r\n\r\n            Assert.AreEqual(new DateTimeOffset(2012, 1, 24, 3, 50, 0, TimeSpan.Zero), reader.ReadAsDateTimeOffset());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTime_DateTimeOffset()\r\n        {\r\n            JValue v = new JValue(new DateTimeOffset(2012, 1, 24, 3, 50, 0, TimeSpan.Zero));\r\n\r\n            JTokenReader reader = new JTokenReader(v);\r\n\r\n            Assert.AreEqual(new DateTime(2012, 1, 24, 3, 50, 0, DateTimeKind.Utc), reader.ReadAsDateTime());\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void ReadAsDateTime_String()\r\n        {\r\n            JValue v = new JValue(\"2012-01-24T03:50Z\");\r\n\r\n            JTokenReader reader = new JTokenReader(v);\r\n\r\n            Assert.AreEqual(new DateTime(2012, 1, 24, 3, 50, 0, DateTimeKind.Utc), reader.ReadAsDateTime());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDouble_String_Success()\r\n        {\r\n            JValue s = JValue.CreateString(\"123.4\");\r\n\r\n            JTokenReader reader = new JTokenReader(s);\r\n\r\n            Assert.AreEqual(123.4d, reader.ReadAsDouble());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDouble_Null_Success()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsDouble());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDouble_Integer_Success()\r\n        {\r\n            JValue n = new JValue(1);\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(1d, reader.ReadAsDouble());\r\n        }\r\n\r\n#if !(NET20 || NET35 || PORTABLE40 || PORTABLE) || NETSTANDARD1_1\r\n        [Test]\r\n        public void ReadAsBoolean_BigInteger_Success()\r\n        {\r\n            JValue s = new JValue(BigInteger.Parse(\"99999999999999999999999999999999999999999999999999999999999999999999999999\"));\r\n\r\n            JTokenReader reader = new JTokenReader(s);\r\n\r\n            Assert.AreEqual(true, reader.ReadAsBoolean());\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void ReadAsBoolean_String_Success()\r\n        {\r\n            JValue s = JValue.CreateString(\"true\");\r\n\r\n            JTokenReader reader = new JTokenReader(s);\r\n\r\n            Assert.AreEqual(true, reader.ReadAsBoolean());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBoolean_Null_Success()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsBoolean());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBoolean_Integer_Success()\r\n        {\r\n            JValue n = new JValue(1);\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(true, reader.ReadAsBoolean());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsDateTime_Null_Success()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsDateTime());\r\n        }\r\n\r\n#if !NET20\r\n        [Test]\r\n        public void ReadAsDateTimeOffset_Null_Success()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsDateTimeOffset());\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void ReadAsString_Integer_Success()\r\n        {\r\n            JValue n = new JValue(1);\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(\"1\", reader.ReadAsString());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsString_Guid_Success()\r\n        {\r\n            JValue n = new JValue(new Uri(\"http://www.test.com\"));\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(\"http://www.test.com\", reader.ReadAsString());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBytes_Integer_Success()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsBytes());\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBytes_Array()\r\n        {\r\n            JArray a = new JArray\r\n            {\r\n                1, 2\r\n            };\r\n\r\n            JTokenReader reader = new JTokenReader(a);\r\n\r\n            byte[] bytes = reader.ReadAsBytes();\r\n\r\n            Assert.AreEqual(2, bytes.Length);\r\n            Assert.AreEqual(1, bytes[0]);\r\n            Assert.AreEqual(2, bytes[1]);\r\n        }\r\n\r\n        [Test]\r\n        public void ReadAsBytes_Null()\r\n        {\r\n            JValue n = JValue.CreateNull();\r\n\r\n            JTokenReader reader = new JTokenReader(n);\r\n\r\n            Assert.AreEqual(null, reader.ReadAsBytes());\r\n        }\r\n    }\r\n}",
                "test_imports": [
                    "using System;",
                    "using System.Collections.Generic;",
                    "using System.Text;",
                    "using NUnit.Framework;",
                    "using Newtonsoft.Json;",
                    "using System.IO;",
                    "using System.Numerics;",
                    "using Newtonsoft.Json.Linq;",
                    "using Newtonsoft.Json.Tests.Serialization;",
                    "using Newtonsoft.Json.Tests.TestObjects;"
                ],
                "test_namespace": "Newtonsoft.Json.Tests.Linq",
                "test_class_name": "JTokenReaderTest",
                "test_file_path": "Newtonsoft.Json.Tests/Linq/JTokenReaderTest.cs",
                "test_runner": "NUnit",
                "project_path": "Newtonsoft.Json.Tests/Newtonsoft.Json.Tests.csproj"
            },
            {
                "tests": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Globalization;\r\nusing System.IO;\r\nusing Newtonsoft.Json.Linq;\r\n#if !(NET20 || NET35 || PORTABLE || PORTABLE40) || NETSTANDARD1_1\r\nusing System.Numerics;\r\n#endif\r\nusing System.Runtime.Serialization;\r\nusing System.Runtime.Serialization.Formatters;\r\nusing System.Text;\r\n#if DNXCORE50\r\nusing Xunit;\r\nusing Test = Xunit.FactAttribute;\r\nusing Assert = Newtonsoft.Json.Tests.XUnitAssert;\r\n#else\r\nusing NUnit.Framework;\r\n#endif\r\nusing Newtonsoft.Json.Converters;\r\nusing Newtonsoft.Json.Serialization;\r\nusing Newtonsoft.Json.Tests.TestObjects;\r\nusing Newtonsoft.Json.Tests.TestObjects.Organization;\r\nusing Newtonsoft.Json.Utilities;\r\n#if NET20\r\nusing Newtonsoft.Json.Utilities.LinqBridge;\r\n#else\r\nusing System.Linq;\r\n\r\n#endif\r\n\r\nnamespace Newtonsoft.Json.Tests.Serialization\r\n{\r\n    public class Staff\r\n    {\r\n        public string Name { get; set; }\r\n        public DateTime StartDate { get; set; }\r\n        public IList<string> Roles { get; set; }\r\n    }\r\n\r\n    [TestFixture]\r\n    public class TraceWriterTests : TestFixtureBase\r\n    {\r\n#if !(PORTABLE || DNXCORE50 || PORTABLE40)\r\n        [Test]\r\n        public void DiagnosticsTraceWriterTest()\r\n        {\r\n            StringWriter sw = new StringWriter();\r\n            TextWriterTraceListener listener = new TextWriterTraceListener(sw);\r\n\r\n            try\r\n            {\r\n                Trace.AutoFlush = true;\r\n                Trace.Listeners.Add(listener);\r\n\r\n                DiagnosticsTraceWriter traceWriter = new DiagnosticsTraceWriter();\r\n                traceWriter.Trace(TraceLevel.Verbose, \"Verbose!\", null);\r\n                traceWriter.Trace(TraceLevel.Info, \"Info!\", null);\r\n                traceWriter.Trace(TraceLevel.Warning, \"Warning!\", null);\r\n                traceWriter.Trace(TraceLevel.Error, \"Error!\", null);\r\n                traceWriter.Trace(TraceLevel.Off, \"Off!\", null);\r\n\r\n                StringAssert.AreEqual(@\"Newtonsoft.Json Verbose: 0 : Verbose!\r\nNewtonsoft.Json Information: 0 : Info!\r\nNewtonsoft.Json Warning: 0 : Warning!\r\nNewtonsoft.Json Error: 0 : Error!\r\n\", sw.ToString());\r\n            }\r\n            finally\r\n            {\r\n                Trace.Listeners.Remove(listener);\r\n                Trace.AutoFlush = false;\r\n            }\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void WriteNullableByte()\r\n        {\r\n            StringWriter sw = new StringWriter();\r\n            TraceJsonWriter traceJsonWriter = new TraceJsonWriter(new JsonTextWriter(sw));\r\n            traceJsonWriter.WriteStartArray();\r\n            traceJsonWriter.WriteValue((byte?)null);\r\n            traceJsonWriter.WriteEndArray();\r\n\r\n            StringAssert.AreEqual(@\"Serialized JSON: \r\n[\r\n  null\r\n]\", traceJsonWriter.GetSerializedJsonMessage());\r\n        }\r\n\r\n        [Test]\r\n        public void WriteJRaw()\r\n        {\r\n            ITraceWriter traceWriter = new MemoryTraceWriter();\r\n\r\n            JRaw settings = new JRaw(\"$('#element')\");\r\n            string json = JsonConvert.SerializeObject(settings, new JsonSerializerSettings\r\n            {\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.AreEqual(\"$('#element')\", json);\r\n\r\n            Assert.IsTrue(traceWriter.ToString().EndsWith(\"Verbose Serialized JSON: \" + Environment.NewLine + \"$('#element')\", StringComparison.Ordinal));\r\n        }\r\n\r\n        [Test]\r\n        public void WriteJRawInArray()\r\n        {\r\n            ITraceWriter traceWriter = new MemoryTraceWriter();\r\n\r\n            List<JRaw> raws = new List<JRaw>\r\n            {\r\n                new JRaw(\"$('#element')\"),\r\n                new JRaw(\"$('#element')\"),\r\n                new JRaw(\"$('#element')\")\r\n            };\r\n\r\n            string json = JsonConvert.SerializeObject(raws, new JsonSerializerSettings\r\n            {\r\n                TraceWriter = traceWriter,\r\n                Formatting = Formatting.Indented\r\n            });\r\n\r\n            StringAssert.AreEqual(@\"[\r\n  $('#element'),\r\n  $('#element'),\r\n  $('#element')\r\n]\", json);\r\n\r\n            Assert.IsTrue(traceWriter.ToString().EndsWith(@\"Verbose Serialized JSON: \r\n[\r\n  $('#element'),\r\n  $('#element'),\r\n  $('#element')\r\n]\", StringComparison.Ordinal));\r\n        }\r\n\r\n        [Test]\r\n        public void MemoryTraceWriterSerializeTest()\r\n        {\r\n            Staff staff = new Staff();\r\n            staff.Name = \"Arnie Admin\";\r\n            staff.Roles = new List<string> { \"Administrator\" };\r\n            staff.StartDate = new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc);\r\n\r\n            ITraceWriter traceWriter = new MemoryTraceWriter();\r\n\r\n            JsonConvert.SerializeObject(\r\n                staff,\r\n                new JsonSerializerSettings { TraceWriter = traceWriter, Converters = { new JavaScriptDateTimeConverter() } });\r\n\r\n            // 2012-11-11T12:08:42.761 Info Started serializing Newtonsoft.Json.Tests.Serialization.Staff. Path ''.\r\n            // 2012-11-11T12:08:42.785 Info Started serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path 'StartDate'.\r\n            // 2012-11-11T12:08:42.791 Info Finished serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path 'StartDate'.\r\n            // 2012-11-11T12:08:42.797 Info Started serializing System.Collections.Generic.List`1[System.String]. Path 'Roles'.\r\n            // 2012-11-11T12:08:42.798 Info Finished serializing System.Collections.Generic.List`1[System.String]. Path 'Roles'.\r\n            // 2012-11-11T12:08:42.799 Info Finished serializing Newtonsoft.Json.Tests.Serialization.Staff. Path ''.\r\n\r\n            MemoryTraceWriter memoryTraceWriter = (MemoryTraceWriter)traceWriter;\r\n            string output = memoryTraceWriter.ToString();\r\n\r\n            Assert.AreEqual(916, output.Length);\r\n            Assert.AreEqual(7, memoryTraceWriter.GetTraceMessages().Count());\r\n\r\n            string json = @\"Serialized JSON: \r\n{\r\n  \"\"Name\"\": \"\"Arnie Admin\"\",\r\n  \"\"StartDate\"\": new Date(\r\n    976623132000\r\n  ),\r\n  \"\"Roles\"\": [\r\n    \"\"Administrator\"\"\r\n  ]\r\n}\";\r\n\r\n            json = StringAssert.Normalize(json);\r\n            output = StringAssert.Normalize(output);\r\n\r\n            Assert.IsTrue(output.Contains(json));\r\n        }\r\n\r\n        [Test]\r\n        public void MemoryTraceWriterDeserializeTest()\r\n        {\r\n            string json = @\"{\r\n  \"\"Name\"\": \"\"Arnie Admin\"\",\r\n  \"\"StartDate\"\": new Date(\r\n    976623132000\r\n  ),\r\n  \"\"Roles\"\": [\r\n    \"\"Administrator\"\"\r\n  ]\r\n}\";\r\n\r\n            Staff staff = new Staff();\r\n            staff.Name = \"Arnie Admin\";\r\n            staff.Roles = new List<string> { \"Administrator\" };\r\n            staff.StartDate = new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc);\r\n\r\n            ITraceWriter traceWriter = new MemoryTraceWriter();\r\n\r\n            JsonConvert.DeserializeObject<Staff>(\r\n                json,\r\n                new JsonSerializerSettings\r\n                {\r\n                    TraceWriter = traceWriter,\r\n                    Converters = { new JavaScriptDateTimeConverter() },\r\n                    MetadataPropertyHandling = MetadataPropertyHandling.Default\r\n                });\r\n\r\n            // 2012-11-11T12:08:42.761 Info Started serializing Newtonsoft.Json.Tests.Serialization.Staff. Path ''.\r\n            // 2012-11-11T12:08:42.785 Info Started serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path 'StartDate'.\r\n            // 2012-11-11T12:08:42.791 Info Finished serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path 'StartDate'.\r\n            // 2012-11-11T12:08:42.797 Info Started serializing System.Collections.Generic.List`1[System.String]. Path 'Roles'.\r\n            // 2012-11-11T12:08:42.798 Info Finished serializing System.Collections.Generic.List`1[System.String]. Path 'Roles'.\r\n            // 2012-11-11T12:08:42.799 Info Finished serializing Newtonsoft.Json.Tests.Serialization.Staff. Path ''.\r\n            // 2013-05-19T00:07:24.360 Verbose Deserialized JSON: \r\n            // {\r\n            //   \"Name\": \"Arnie Admin\",\r\n            //   \"StartDate\": new Date(\r\n            //     976623132000\r\n            //   ),\r\n            //   \"Roles\": [\r\n            //     \"Administrator\"\r\n            //   ]\r\n            // }\r\n\r\n            MemoryTraceWriter memoryTraceWriter = (MemoryTraceWriter)traceWriter;\r\n            string output = memoryTraceWriter.ToString();\r\n\r\n            Assert.AreEqual(1058, output.Length);\r\n            Assert.AreEqual(7, memoryTraceWriter.GetTraceMessages().Count());\r\n\r\n            json = StringAssert.Normalize(json);\r\n            output = StringAssert.Normalize(output);\r\n\r\n            Assert.IsTrue(output.Contains(json));\r\n        }\r\n\r\n        [Test]\r\n        public void MemoryTraceWriterLimitTest()\r\n        {\r\n            MemoryTraceWriter traceWriter = new MemoryTraceWriter();\r\n\r\n            for (int i = 0; i < 1005; i++)\r\n            {\r\n                traceWriter.Trace(TraceLevel.Verbose, (i + 1).ToString(CultureInfo.InvariantCulture), null);\r\n            }\r\n\r\n            IList<string> traceMessages = traceWriter.GetTraceMessages().ToList();\r\n\r\n            Assert.AreEqual(1000, traceMessages.Count);\r\n\r\n            Assert.IsTrue(traceMessages.First().EndsWith(\" 6\"));\r\n            Assert.IsTrue(traceMessages.Last().EndsWith(\" 1005\"));\r\n        }\r\n\r\n        [Test]\r\n        public void Serialize()\r\n        {\r\n            var traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Info\r\n            };\r\n\r\n            string json =\r\n                JsonConvert.SerializeObject(\r\n                    new TraceTestObject\r\n                    {\r\n                        StringArray = new[] { \"1\", \"2\" },\r\n                        IntList = new List<int> { 1, 2 },\r\n                        Version = new Version(1, 2, 3, 4),\r\n                        StringDictionary =\r\n                            new Dictionary<string, string>\r\n                            {\r\n                                { \"1\", \"!\" },\r\n                                { \"Two\", \"!!\" },\r\n                                { \"III\", \"!!!\" }\r\n                            },\r\n                        Double = 1.1d\r\n                    },\r\n                    new JsonSerializerSettings\r\n                    {\r\n                        TraceWriter = traceWriter,\r\n                        Formatting = Formatting.Indented\r\n                    });\r\n\r\n            Assert.AreEqual(\"Started serializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path ''.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started serializing System.Collections.Generic.List`1[System.Int32]. Path 'IntList'.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Collections.Generic.List`1[System.Int32]. Path 'IntList'.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"Started serializing System.String[]. Path 'StringArray'.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.AreEqual(\"Finished serializing System.String[]. Path 'StringArray'.\", traceWriter.TraceRecords[4].Message);\r\n            Assert.AreEqual(\"Started serializing System.Version. Path 'Version'.\", traceWriter.TraceRecords[5].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Version. Path 'Version'.\", traceWriter.TraceRecords[6].Message);\r\n            Assert.AreEqual(\"Started serializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path 'StringDictionary'.\", traceWriter.TraceRecords[7].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path 'StringDictionary'.\", traceWriter.TraceRecords[8].Message);\r\n            Assert.AreEqual(\"Finished serializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path ''.\", traceWriter.TraceRecords[9].Message);\r\n\r\n            Assert.IsFalse(traceWriter.TraceRecords.Any(r => r.Level == TraceLevel.Verbose));\r\n        }\r\n\r\n        [Test]\r\n        public void Deserialize()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Info\r\n            };\r\n\r\n            TraceTestObject o2 = JsonConvert.DeserializeObject<TraceTestObject>(\r\n                @\"{\r\n  \"\"IntList\"\": [\r\n    1,\r\n    2\r\n  ],\r\n  \"\"StringArray\"\": [\r\n    \"\"1\"\",\r\n    \"\"2\"\"\r\n  ],\r\n  \"\"Version\"\": {\r\n    \"\"Major\"\": 1,\r\n    \"\"Minor\"\": 2,\r\n    \"\"Build\"\": 3,\r\n    \"\"Revision\"\": 4,\r\n    \"\"MajorRevision\"\": 0,\r\n    \"\"MinorRevision\"\": 4\r\n  },\r\n  \"\"StringDictionary\"\": {\r\n    \"\"1\"\": \"\"!\"\",\r\n    \"\"Two\"\": \"\"!!\"\",\r\n    \"\"III\"\": \"\"!!!\"\"\r\n  },\r\n  \"\"Double\"\": 1.1\r\n}\",\r\n                new JsonSerializerSettings\r\n                {\r\n                    TraceWriter = traceWriter\r\n                });\r\n\r\n            Assert.AreEqual(2, o2.IntList.Count);\r\n            Assert.AreEqual(2, o2.StringArray.Length);\r\n            Assert.AreEqual(1, o2.Version.Major);\r\n            Assert.AreEqual(2, o2.Version.Minor);\r\n            Assert.AreEqual(3, o2.StringDictionary.Count);\r\n            Assert.AreEqual(1.1d, o2.Double);\r\n\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path 'IntList', line 2, position 12.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.IList`1[System.Int32]. Path 'IntList', line 2, position 14.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[2].Message.StartsWith(\"Finished deserializing System.Collections.Generic.IList`1[System.Int32]. Path 'IntList'\"));\r\n            Assert.AreEqual(\"Started deserializing System.String[]. Path 'StringArray', line 6, position 18.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[4].Message.StartsWith(\"Finished deserializing System.String[]. Path 'StringArray'\"));\r\n            Assert.AreEqual(\"Deserializing System.Version using creator with parameters: Major, Minor, Build, Revision. Path 'Version.Major', line 11, position 12.\", traceWriter.TraceRecords[5].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[6].Message.StartsWith(\"Started deserializing System.Version. Path 'Version'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[7].Message.StartsWith(\"Finished deserializing System.Version. Path 'Version'\"));\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.IDictionary`2[System.String,System.String]. Path 'StringDictionary.1', line 19, position 8.\", traceWriter.TraceRecords[8].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[9].Message.StartsWith(\"Finished deserializing System.Collections.Generic.IDictionary`2[System.String,System.String]. Path 'StringDictionary'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[10].Message.StartsWith(\"Finished deserializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path ''\"));\r\n\r\n            Assert.IsFalse(traceWriter.TraceRecords.Any(r => r.Level == TraceLevel.Verbose));\r\n        }\r\n\r\n        [Test]\r\n        public void Populate()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Info\r\n            };\r\n\r\n            TraceTestObject o2 = new TraceTestObject();\r\n\r\n            JsonConvert.PopulateObject(@\"{\r\n  \"\"IntList\"\": [\r\n    1,\r\n    2\r\n  ],\r\n  \"\"StringArray\"\": [\r\n    \"\"1\"\",\r\n    \"\"2\"\"\r\n  ],\r\n  \"\"Version\"\": {\r\n    \"\"Major\"\": 1,\r\n    \"\"Minor\"\": 2,\r\n    \"\"Build\"\": 3,\r\n    \"\"Revision\"\": 4,\r\n    \"\"MajorRevision\"\": 0,\r\n    \"\"MinorRevision\"\": 4\r\n  },\r\n  \"\"StringDictionary\"\": {\r\n    \"\"1\"\": \"\"!\"\",\r\n    \"\"Two\"\": \"\"!!\"\",\r\n    \"\"III\"\": \"\"!!!\"\"\r\n  },\r\n  \"\"Double\"\": 1.1\r\n}\",\r\n                o2,\r\n                new JsonSerializerSettings\r\n                {\r\n                    TraceWriter = traceWriter,\r\n                    MetadataPropertyHandling = MetadataPropertyHandling.Default\r\n                });\r\n\r\n            Assert.AreEqual(2, o2.IntList.Count);\r\n            Assert.AreEqual(2, o2.StringArray.Length);\r\n            Assert.AreEqual(1, o2.Version.Major);\r\n            Assert.AreEqual(2, o2.Version.Minor);\r\n            Assert.AreEqual(3, o2.StringDictionary.Count);\r\n            Assert.AreEqual(1.1d, o2.Double);\r\n\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path 'IntList', line 2, position 12.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.IList`1[System.Int32]. Path 'IntList', line 2, position 14.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[2].Message.StartsWith(\"Finished deserializing System.Collections.Generic.IList`1[System.Int32]. Path 'IntList'\"));\r\n            Assert.AreEqual(\"Started deserializing System.String[]. Path 'StringArray', line 6, position 18.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[4].Message.StartsWith(\"Finished deserializing System.String[]. Path 'StringArray'\"));\r\n            Assert.AreEqual(\"Deserializing System.Version using creator with parameters: Major, Minor, Build, Revision. Path 'Version.Major', line 11, position 12.\", traceWriter.TraceRecords[5].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[6].Message.StartsWith(\"Started deserializing System.Version. Path 'Version'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[7].Message.StartsWith(\"Finished deserializing System.Version. Path 'Version'\"));\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.IDictionary`2[System.String,System.String]. Path 'StringDictionary.1', line 19, position 8.\", traceWriter.TraceRecords[8].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[9].Message.StartsWith(\"Finished deserializing System.Collections.Generic.IDictionary`2[System.String,System.String]. Path 'StringDictionary'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[10].Message.StartsWith(\"Finished deserializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path ''\"));\r\n\r\n            Assert.IsFalse(traceWriter.TraceRecords.Any(r => r.Level == TraceLevel.Verbose));\r\n        }\r\n\r\n        [Test]\r\n        public void ErrorDeserializing()\r\n        {\r\n            string json = @\"{\"\"Integer\"\":\"\"hi\"\"}\";\r\n\r\n            var traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Info\r\n            };\r\n\r\n            ExceptionAssert.Throws<Exception>(() =>\r\n            {\r\n                JsonConvert.DeserializeObject<IntegerTestClass>(\r\n                    json,\r\n                    new JsonSerializerSettings\r\n                    {\r\n                        TraceWriter = traceWriter\r\n                    });\r\n            }, \"Could not convert string to integer: hi. Path 'Integer', line 1, position 15.\");\r\n\r\n            Assert.AreEqual(2, traceWriter.TraceRecords.Count);\r\n\r\n            Assert.AreEqual(TraceLevel.Info, traceWriter.TraceRecords[0].Level);\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.IntegerTestClass. Path 'Integer', line 1, position 11.\", traceWriter.TraceRecords[0].Message);\r\n\r\n            Assert.AreEqual(TraceLevel.Error, traceWriter.TraceRecords[1].Level);\r\n            Assert.AreEqual(\"Error deserializing Newtonsoft.Json.Tests.Serialization.IntegerTestClass. Could not convert string to integer: hi. Path 'Integer', line 1, position 15.\", traceWriter.TraceRecords[1].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void ErrorDeserializingNested()\r\n        {\r\n            string json = @\"{\"\"IntList\"\":[1, \"\"two\"\"]}\";\r\n\r\n            var traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Info\r\n            };\r\n\r\n            ExceptionAssert.Throws<Exception>(() =>\r\n            {\r\n                JsonConvert.DeserializeObject<TraceTestObject>(\r\n                    json,\r\n                    new JsonSerializerSettings\r\n                    {\r\n                        TraceWriter = traceWriter\r\n                    });\r\n            }, \"Could not convert string to integer: two. Path 'IntList[1]', line 1, position 20.\");\r\n\r\n            Assert.AreEqual(3, traceWriter.TraceRecords.Count);\r\n\r\n            Assert.AreEqual(TraceLevel.Info, traceWriter.TraceRecords[0].Level);\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.TraceTestObject. Path 'IntList', line 1, position 11.\", traceWriter.TraceRecords[0].Message);\r\n\r\n            Assert.AreEqual(TraceLevel.Info, traceWriter.TraceRecords[1].Level);\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.IList`1[System.Int32]. Path 'IntList', line 1, position 12.\", traceWriter.TraceRecords[1].Message);\r\n\r\n            Assert.AreEqual(TraceLevel.Error, traceWriter.TraceRecords[2].Level);\r\n            Assert.AreEqual(\"Error deserializing System.Collections.Generic.IList`1[System.Int32]. Could not convert string to integer: two. Path 'IntList[1]', line 1, position 20.\", traceWriter.TraceRecords[2].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void SerializeDictionarysWithPreserveObjectReferences()\r\n        {\r\n            PreserveReferencesHandlingTests.CircularDictionary circularDictionary = new PreserveReferencesHandlingTests.CircularDictionary();\r\n            circularDictionary.Add(\"other\", new PreserveReferencesHandlingTests.CircularDictionary { { \"blah\", null } });\r\n            circularDictionary.Add(\"self\", circularDictionary);\r\n\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            JsonConvert.SerializeObject(\r\n                circularDictionary,\r\n                Formatting.Indented,\r\n                new JsonSerializerSettings\r\n                {\r\n                    PreserveReferencesHandling = PreserveReferencesHandling.All,\r\n                    TraceWriter = traceWriter\r\n                });\r\n\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message == \"Writing object reference Id '1' for Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path ''.\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message == \"Writing object reference Id '2' for Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path 'other'.\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message == \"Writing object reference to Id '1' for Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path 'self'.\"));\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeDictionarysWithPreserveObjectReferences()\r\n        {\r\n            string json = @\"{\r\n  \"\"$id\"\": \"\"1\"\",\r\n  \"\"other\"\": {\r\n    \"\"$id\"\": \"\"2\"\",\r\n    \"\"blah\"\": null\r\n  },\r\n  \"\"self\"\": {\r\n    \"\"$ref\"\": \"\"1\"\"\r\n  }\r\n}\";\r\n\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            JsonConvert.DeserializeObject<PreserveReferencesHandlingTests.CircularDictionary>(json,\r\n                new JsonSerializerSettings\r\n                {\r\n                    PreserveReferencesHandling = PreserveReferencesHandling.All,\r\n                    MetadataPropertyHandling = MetadataPropertyHandling.Default,\r\n                    TraceWriter = traceWriter\r\n                });\r\n\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message == \"Read object reference Id '1' for Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path 'other', line 3, position 10.\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message == \"Read object reference Id '2' for Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path 'other.blah', line 5, position 11.\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords.Any(r => r.Message.StartsWith(\"Resolved object reference '1' to Newtonsoft.Json.Tests.Serialization.PreserveReferencesHandlingTests+CircularDictionary. Path 'self'\")));\r\n        }\r\n\r\n        [Test]\r\n        public void WriteTypeNameForObjects()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            IList<object> l = new List<object>\r\n            {\r\n                new Dictionary<string, string> { { \"key!\", \"value!\" } },\r\n                new Version(1, 2, 3, 4)\r\n            };\r\n\r\n            JsonConvert.SerializeObject(l, Formatting.Indented, new JsonSerializerSettings\r\n            {\r\n                TypeNameHandling = TypeNameHandling.All,\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.AreEqual(\"Started serializing System.Collections.Generic.List`1[System.Object]. Path ''.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Writing type name '\" + ReflectionUtils.GetTypeName(typeof(List<object>), 0, DefaultSerializationBinder.Instance) + \"' for System.Collections.Generic.List`1[System.Object]. Path ''.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"Started serializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values'.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"Writing type name '\" + ReflectionUtils.GetTypeName(typeof(Dictionary<string, string>), 0, DefaultSerializationBinder.Instance) + \"' for System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values[0]'.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values[0]'.\", traceWriter.TraceRecords[4].Message);\r\n            Assert.AreEqual(\"Started serializing System.Version. Path '$values[0]'.\", traceWriter.TraceRecords[5].Message);\r\n            Assert.AreEqual(\"Writing type name '\" + ReflectionUtils.GetTypeName(typeof(Version), 0, DefaultSerializationBinder.Instance) + \"' for System.Version. Path '$values[1]'.\", traceWriter.TraceRecords[6].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Version. Path '$values[1]'.\", traceWriter.TraceRecords[7].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Collections.Generic.List`1[System.Object]. Path ''.\", traceWriter.TraceRecords[8].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void SerializeConverter()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            IList<DateTime> d = new List<DateTime>\r\n            {\r\n                new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc)\r\n            };\r\n\r\n            string json = JsonConvert.SerializeObject(d, Formatting.Indented, new JsonSerializerSettings\r\n            {\r\n                Converters = { new JavaScriptDateTimeConverter() },\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.AreEqual(\"Started serializing System.Collections.Generic.List`1[System.DateTime]. Path ''.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path ''.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"Finished serializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path '[0]'.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"Finished serializing System.Collections.Generic.List`1[System.DateTime]. Path ''.\", traceWriter.TraceRecords[3].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeConverter()\r\n        {\r\n            string json = @\"[new Date(976623132000)]\";\r\n\r\n            InMemoryTraceWriter traceWriter =\r\n                new InMemoryTraceWriter\r\n                {\r\n                    LevelFilter = TraceLevel.Verbose\r\n                };\r\n\r\n            JsonConvert.DeserializeObject<List<DateTime>>(\r\n                json,\r\n                new JsonSerializerSettings\r\n                {\r\n                    Converters = { new JavaScriptDateTimeConverter() },\r\n                    TraceWriter = traceWriter\r\n                });\r\n\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.List`1[System.DateTime]. Path '', line 1, position 1.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started deserializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path '[0]', line 1, position 10.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"Finished deserializing System.DateTime with converter Newtonsoft.Json.Converters.JavaScriptDateTimeConverter. Path '[0]', line 1, position 23.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"Finished deserializing System.Collections.Generic.List`1[System.DateTime]. Path '', line 1, position 24.\", traceWriter.TraceRecords[3].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeTypeName()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            string json = @\"{\r\n  \"\"$type\"\": \"\"System.Collections.Generic.List`1[[System.Object, mscorlib]], mscorlib\"\",\r\n  \"\"$values\"\": [\r\n    {\r\n      \"\"$type\"\": \"\"System.Collections.Generic.Dictionary`2[[System.String, mscorlib],[System.String, mscorlib]], mscorlib\"\",\r\n      \"\"key!\"\": \"\"value!\"\"\r\n    },\r\n    {\r\n      \"\"$type\"\": \"\"System.Version, mscorlib\"\",\r\n      \"\"Major\"\": 1,\r\n      \"\"Minor\"\": 2,\r\n      \"\"Build\"\": 3,\r\n      \"\"Revision\"\": 4,\r\n      \"\"MajorRevision\"\": 0,\r\n      \"\"MinorRevision\"\": 4\r\n    }\r\n  ]\r\n}\";\r\n\r\n            JsonConvert.DeserializeObject(json, null, new JsonSerializerSettings\r\n            {\r\n                TypeNameHandling = TypeNameHandling.All,\r\n                MetadataPropertyHandling = MetadataPropertyHandling.Default,\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.AreEqual(\"Resolved type 'System.Collections.Generic.List`1[[System.Object, mscorlib]], mscorlib' to System.Collections.Generic.List`1[System.Object]. Path '$type', line 2, position 83.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.List`1[System.Object]. Path '$values', line 3, position 14.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"Resolved type 'System.Collections.Generic.Dictionary`2[[System.String, mscorlib],[System.String, mscorlib]], mscorlib' to System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values[0].$type', line 5, position 119.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"Started deserializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values[0].key!', line 6, position 13.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[4].Message.StartsWith(\"Finished deserializing System.Collections.Generic.Dictionary`2[System.String,System.String]. Path '$values[0]'\"));\r\n            Assert.AreEqual(\"Resolved type 'System.Version, mscorlib' to System.Version. Path '$values[1].$type', line 9, position 41.\", traceWriter.TraceRecords[5].Message);\r\n            Assert.AreEqual(\"Deserializing System.Version using creator with parameters: Major, Minor, Build, Revision. Path '$values[1].Major', line 10, position 14.\", traceWriter.TraceRecords[6].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[7].Message.StartsWith(\"Started deserializing System.Version. Path '$values[1]'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[8].Message.StartsWith(\"Finished deserializing System.Version. Path '$values[1]'\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[9].Message.StartsWith(\"Finished deserializing System.Collections.Generic.List`1[System.Object]. Path '$values'\"));\r\n        }\r\n\r\n#if !(PORTABLE || DNXCORE50 || PORTABLE40)\r\n        [Test]\r\n        public void DeserializeISerializable()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            ExceptionAssert.Throws<SerializationException>(() =>\r\n            {\r\n                JsonConvert.DeserializeObject<Exception>(\r\n                    \"{}\",\r\n                    new JsonSerializerSettings\r\n                    {\r\n                        TraceWriter = traceWriter\r\n                    });\r\n            }, \"Member 'ClassName' was not found.\");\r\n\r\n            Assert.IsTrue(traceWriter.TraceRecords[0].Message.StartsWith(\"Deserializing System.Exception using ISerializable constructor. Path ''\"));\r\n            Assert.AreEqual(TraceLevel.Info, traceWriter.TraceRecords[0].Level);\r\n            Assert.AreEqual(\"Error deserializing System.Exception. Member 'ClassName' was not found. Path '', line 1, position 2.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(TraceLevel.Error, traceWriter.TraceRecords[1].Level);\r\n        }\r\n#endif\r\n\r\n        [Test]\r\n        public void DeserializeMissingMember()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            JsonConvert.DeserializeObject<Person>(\r\n                \"{'MissingMemberProperty':'!!'}\",\r\n                new JsonSerializerSettings\r\n                {\r\n                    TraceWriter = traceWriter\r\n                });\r\n\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.TestObjects.Organization.Person. Path 'MissingMemberProperty', line 1, position 25.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Could not find member 'MissingMemberProperty' on Newtonsoft.Json.Tests.TestObjects.Organization.Person. Path 'MissingMemberProperty', line 1, position 25.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[2].Message.StartsWith(\"Finished deserializing Newtonsoft.Json.Tests.TestObjects.Organization.Person. Path ''\"));\r\n        }\r\n\r\n        [Test]\r\n        public void DeserializeMissingMemberConstructor()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            string json = @\"{\r\n  \"\"Major\"\": 1,\r\n  \"\"Minor\"\": 2,\r\n  \"\"Build\"\": 3,\r\n  \"\"Revision\"\": 4,\r\n  \"\"MajorRevision\"\": 0,\r\n  \"\"MinorRevision\"\": 4,\r\n  \"\"MissingMemberProperty\"\": null\r\n}\";\r\n\r\n            JsonConvert.DeserializeObject<Version>(json, new JsonSerializerSettings\r\n            {\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.AreEqual(\"Deserializing System.Version using creator with parameters: Major, Minor, Build, Revision. Path 'Major', line 2, position 10.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"Could not find member 'MissingMemberProperty' on System.Version. Path 'MissingMemberProperty', line 8, position 31.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[2].Message.StartsWith(\"Started deserializing System.Version. Path ''\"));\r\n            Assert.IsTrue(traceWriter.TraceRecords[3].Message.StartsWith(\"Finished deserializing System.Version. Path ''\"));\r\n        }\r\n\r\n        [Test]\r\n        public void PublicParameterizedConstructorWithPropertyNameConflictWithAttribute()\r\n        {\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            string json = @\"{name:\"\"1\"\"}\";\r\n\r\n            PublicParameterizedConstructorWithPropertyNameConflictWithAttribute c = JsonConvert.DeserializeObject<PublicParameterizedConstructorWithPropertyNameConflictWithAttribute>(json, new JsonSerializerSettings\r\n            {\r\n                TraceWriter = traceWriter\r\n            });\r\n\r\n            Assert.IsNotNull(c);\r\n            Assert.AreEqual(1, c.Name);\r\n\r\n            Assert.AreEqual(\"Deserializing Newtonsoft.Json.Tests.TestObjects.PublicParameterizedConstructorWithPropertyNameConflictWithAttribute using creator with parameters: name. Path 'name', line 1, position 6.\", traceWriter.TraceRecords[0].Message);\r\n        }\r\n\r\n        [Test]\r\n        public void ShouldSerializeTestClass()\r\n        {\r\n            ShouldSerializeTestClass c = new ShouldSerializeTestClass();\r\n            c.Age = 29;\r\n            c.Name = \"Jim\";\r\n            c._shouldSerializeName = true;\r\n\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            JsonConvert.SerializeObject(c, new JsonSerializerSettings { TraceWriter = traceWriter });\r\n\r\n            Assert.AreEqual(\"ShouldSerialize result for property 'Name' on Newtonsoft.Json.Tests.Serialization.ShouldSerializeTestClass: True. Path ''.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(TraceLevel.Verbose, traceWriter.TraceRecords[1].Level);\r\n\r\n            traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            c._shouldSerializeName = false;\r\n\r\n            JsonConvert.SerializeObject(c, new JsonSerializerSettings { TraceWriter = traceWriter });\r\n\r\n            Assert.AreEqual(\"ShouldSerialize result for property 'Name' on Newtonsoft.Json.Tests.Serialization.ShouldSerializeTestClass: False. Path ''.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(TraceLevel.Verbose, traceWriter.TraceRecords[1].Level);\r\n        }\r\n\r\n        [Test]\r\n        public void SpecifiedTest()\r\n        {\r\n            SpecifiedTestClass c = new SpecifiedTestClass();\r\n            c.Name = \"James\";\r\n            c.Age = 27;\r\n            c.NameSpecified = false;\r\n\r\n            InMemoryTraceWriter traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            string json = JsonConvert.SerializeObject(c, Formatting.Indented, new JsonSerializerSettings { TraceWriter = traceWriter });\r\n\r\n            Assert.AreEqual(\"Started serializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path ''.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"IsSpecified result for property 'Name' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass: False. Path ''.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"IsSpecified result for property 'Weight' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass: False. Path 'Age'.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"IsSpecified result for property 'Height' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass: False. Path 'Age'.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.AreEqual(\"IsSpecified result for property 'FavoriteNumber' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass: False. Path 'Age'.\", traceWriter.TraceRecords[4].Message);\r\n            Assert.AreEqual(\"Finished serializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path ''.\", traceWriter.TraceRecords[5].Message);\r\n\r\n            StringAssert.AreEqual(@\"{\r\n  \"\"Age\"\": 27\r\n}\", json);\r\n\r\n            traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            SpecifiedTestClass deserialized = JsonConvert.DeserializeObject<SpecifiedTestClass>(json, new JsonSerializerSettings { TraceWriter = traceWriter });\r\n\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path 'Age', line 2, position 8.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[1].Message.StartsWith(\"Finished deserializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path ''\"));\r\n\r\n            Assert.IsNull(deserialized.Name);\r\n            Assert.IsFalse(deserialized.NameSpecified);\r\n            Assert.IsFalse(deserialized.WeightSpecified);\r\n            Assert.IsFalse(deserialized.HeightSpecified);\r\n            Assert.IsFalse(deserialized.FavoriteNumberSpecified);\r\n            Assert.AreEqual(27, deserialized.Age);\r\n\r\n            c.NameSpecified = true;\r\n            c.WeightSpecified = true;\r\n            c.HeightSpecified = true;\r\n            c.FavoriteNumber = 23;\r\n            json = JsonConvert.SerializeObject(c, Formatting.Indented);\r\n\r\n            StringAssert.AreEqual(@\"{\r\n  \"\"Name\"\": \"\"James\"\",\r\n  \"\"Age\"\": 27,\r\n  \"\"Weight\"\": 0,\r\n  \"\"Height\"\": 0,\r\n  \"\"FavoriteNumber\"\": 23\r\n}\", json);\r\n\r\n            traceWriter = new InMemoryTraceWriter\r\n            {\r\n                LevelFilter = TraceLevel.Verbose\r\n            };\r\n\r\n            deserialized = JsonConvert.DeserializeObject<SpecifiedTestClass>(json, new JsonSerializerSettings { TraceWriter = traceWriter });\r\n\r\n            Assert.AreEqual(\"Started deserializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path 'Name', line 2, position 9.\", traceWriter.TraceRecords[0].Message);\r\n            Assert.AreEqual(\"IsSpecified for property 'Name' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass set to true. Path 'Name', line 2, position 17.\", traceWriter.TraceRecords[1].Message);\r\n            Assert.AreEqual(\"IsSpecified for property 'Weight' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass set to true. Path 'Weight', line 4, position 13.\", traceWriter.TraceRecords[2].Message);\r\n            Assert.AreEqual(\"IsSpecified for property 'Height' on Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass set to true. Path 'Height', line 5, position 13.\", traceWriter.TraceRecords[3].Message);\r\n            Assert.IsTrue(traceWriter.TraceRecords[4].Message.StartsWith(\"Finished deserializing Newtonsoft.Json.Tests.Serialization.SpecifiedTestClass. Path ''\"));\r\n\r\n            Assert.AreEqual(\"James\", deserialized.Name);\r\n            Assert.IsTrue(deserialized.NameSpecified);\r\n            Assert.IsTrue(deserialized.WeightSpecified);\r\n            Assert.IsTrue(deserialized.HeightSpecified);\r\n            Assert.IsTrue(deserialized.FavoriteNumberSpecified);\r\n            Assert.AreEqual(27, deserialized.Age);\r\n            Assert.AreEqual(23, deserialized.FavoriteNumber);\r\n        }\r\n\r\n#if !(NET20 || NET35 || PORTABLE || PORTABLE40) || NETSTANDARD1_1\r\n        [Test]\r\n        public void TraceJsonWriterTest()\r\n        {\r\n            StringWriter sw = new StringWriter(CultureInfo.InvariantCulture);\r\n            JsonTextWriter w = new JsonTextWriter(sw);\r\n            TraceJsonWriter traceWriter = new TraceJsonWriter(w);\r\n\r\n            traceWriter.WriteStartObject();\r\n            traceWriter.WritePropertyName(\"Array\");\r\n            traceWriter.WriteStartArray();\r\n            traceWriter.WriteValue(\"String!\");\r\n            traceWriter.WriteValue(new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc));\r\n            traceWriter.WriteValue(new DateTimeOffset(2000, 12, 12, 12, 12, 12, TimeSpan.FromHours(2)));\r\n            traceWriter.WriteValue(1.1f);\r\n            traceWriter.WriteValue(1.1d);\r\n            traceWriter.WriteValue(1.1m);\r\n            traceWriter.WriteValue(1);\r\n            traceWriter.WriteValue((char)'!');\r\n            traceWriter.WriteValue((short)1);\r\n            traceWriter.WriteValue((ushort)1);\r\n            traceWriter.WriteValue((int)1);\r\n            traceWriter.WriteValue((uint)1);\r\n            traceWriter.WriteValue((sbyte)1);\r\n            traceWriter.WriteValue((byte)1);\r\n            traceWriter.WriteValue((long)1);\r\n            traceWriter.WriteValue((ulong)1);\r\n            traceWriter.WriteValue((bool)true);\r\n\r\n            traceWriter.WriteValue((DateTime?)new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc));\r\n            traceWriter.WriteValue((DateTimeOffset?)new DateTimeOffset(2000, 12, 12, 12, 12, 12, TimeSpan.FromHours(2)));\r\n            traceWriter.WriteValue((float?)1.1f);\r\n            traceWriter.WriteValue((double?)1.1d);\r\n            traceWriter.WriteValue((decimal?)1.1m);\r\n            traceWriter.WriteValue((int?)1);\r\n            traceWriter.WriteValue((char?)'!');\r\n            traceWriter.WriteValue((short?)1);\r\n            traceWriter.WriteValue((ushort?)1);\r\n            traceWriter.WriteValue((int?)1);\r\n            traceWriter.WriteValue((uint?)1);\r\n            traceWriter.WriteValue((sbyte?)1);\r\n            traceWriter.WriteValue((byte?)1);\r\n            traceWriter.WriteValue((long?)1);\r\n            traceWriter.WriteValue((ulong?)1);\r\n            traceWriter.WriteValue((bool?)true);\r\n            traceWriter.WriteValue(BigInteger.Parse(\"9999999990000000000000000000000000000000000\"));\r\n\r\n            traceWriter.WriteValue((object)true);\r\n            traceWriter.WriteValue(TimeSpan.FromMinutes(1));\r\n            traceWriter.WriteValue(Guid.Empty);\r\n            traceWriter.WriteValue(new Uri(\"http://www.google.com/\"));\r\n            traceWriter.WriteValue(Encoding.UTF8.GetBytes(\"String!\"));\r\n            traceWriter.WriteRawValue(\"[1],\");\r\n            traceWriter.WriteRaw(\"[2]\");\r\n            traceWriter.WriteNull();\r\n            traceWriter.WriteUndefined();\r\n            traceWriter.WriteStartConstructor(\"ctor\");\r\n            traceWriter.WriteValue(1);\r\n            traceWriter.WriteEndConstructor();\r\n            traceWriter.WriteComment(\"A comment\");\r\n            traceWriter.WriteWhitespace(\"       \");\r\n            traceWriter.WriteEnd();\r\n            traceWriter.WriteEndObject();\r\n            traceWriter.Flush();\r\n            traceWriter.Close();\r\n\r\n            string json = @\"{\r\n  \"\"Array\"\": [\r\n    \"\"String!\"\",\r\n    \"\"2000-12-12T12:12:12Z\"\",\r\n    \"\"2000-12-12T12:12:12+02:00\"\",\r\n    1.1,\r\n    1.1,\r\n    1.1,\r\n    1,\r\n    \"\"!\"\",\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    true,\r\n    \"\"2000-12-12T12:12:12Z\"\",\r\n    \"\"2000-12-12T12:12:12+02:00\"\",\r\n    1.1,\r\n    1.1,\r\n    1.1,\r\n    1,\r\n    \"\"!\"\",\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    true,\r\n    9999999990000000000000000000000000000000000,\r\n    true,\r\n    true,\r\n    \"\"00:01:00\"\",\r\n    \"\"00000000-0000-0000-0000-000000000000\"\",\r\n    \"\"http://www.google.com/\"\",\r\n    \"\"U3RyaW5nIQ==\"\",\r\n    [1],[2],\r\n    null,\r\n    undefined,\r\n    new ctor(\r\n      1\r\n    )\r\n    /*A comment*/       \r\n  ]\r\n}\";\r\n\r\n            StringAssert.AreEqual(\"Serialized JSON: \" + Environment.NewLine + json, traceWriter.GetSerializedJsonMessage());\r\n        }\r\n\r\n        [Test]\r\n        public void TraceJsonReaderTest()\r\n        {\r\n            string json = @\"{\r\n  \"\"Array\"\": [\r\n    \"\"String!\"\",\r\n    \"\"2000-12-12T12:12:12Z\"\",\r\n    \"\"2000-12-12T12:12:12Z\"\",\r\n    \"\"2000-12-12T12:12:12+00:00\"\",\r\n    \"\"U3RyaW5nIQ==\"\",\r\n    1,\r\n    1.1,\r\n    1.2,\r\n    9999999990000000000000000000000000000000000,\r\n    null,\r\n    undefined,\r\n    new ctor(\r\n      1\r\n    )\r\n    /*A comment*/\r\n  ]\r\n}\";\r\n\r\n            StringReader sw = new StringReader(json);\r\n            JsonTextReader w = new JsonTextReader(sw);\r\n            TraceJsonReader traceReader = new TraceJsonReader(w);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.StartObject, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.PropertyName, traceReader.TokenType);\r\n            Assert.AreEqual(\"Array\", traceReader.Value);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.StartArray, traceReader.TokenType);\r\n            Assert.AreEqual(null, traceReader.Value);\r\n\r\n            traceReader.ReadAsString();\r\n            Assert.AreEqual(JsonToken.String, traceReader.TokenType);\r\n            Assert.AreEqual('\"', traceReader.QuoteChar);\r\n            Assert.AreEqual(\"String!\", traceReader.Value);\r\n\r\n            // for great code coverage justice!\r\n            traceReader.QuoteChar = '\\'';\r\n            Assert.AreEqual('\\'', traceReader.QuoteChar);\r\n\r\n            traceReader.ReadAsString();\r\n            Assert.AreEqual(JsonToken.String, traceReader.TokenType);\r\n            Assert.AreEqual(\"2000-12-12T12:12:12Z\", traceReader.Value);\r\n\r\n            traceReader.ReadAsDateTime();\r\n            Assert.AreEqual(JsonToken.Date, traceReader.TokenType);\r\n            Assert.AreEqual(new DateTime(2000, 12, 12, 12, 12, 12, DateTimeKind.Utc), traceReader.Value);\r\n\r\n            traceReader.ReadAsDateTimeOffset();\r\n            Assert.AreEqual(JsonToken.Date, traceReader.TokenType);\r\n            Assert.AreEqual(new DateTimeOffset(2000, 12, 12, 12, 12, 12, TimeSpan.Zero), traceReader.Value);\r\n\r\n            traceReader.ReadAsBytes();\r\n            Assert.AreEqual(JsonToken.Bytes, traceReader.TokenType);\r\n            CollectionAssert.AreEqual(Encoding.UTF8.GetBytes(\"String!\"), (byte[])traceReader.Value);\r\n\r\n            traceReader.ReadAsInt32();\r\n            Assert.AreEqual(JsonToken.Integer, traceReader.TokenType);\r\n            Assert.AreEqual(1, traceReader.Value);\r\n\r\n            traceReader.ReadAsDecimal();\r\n            Assert.AreEqual(JsonToken.Float, traceReader.TokenType);\r\n            Assert.AreEqual(1.1m, traceReader.Value);\r\n\r\n            traceReader.ReadAsDouble();\r\n            Assert.AreEqual(JsonToken.Float, traceReader.TokenType);\r\n            Assert.AreEqual(1.2d, traceReader.Value);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.Integer, traceReader.TokenType);\r\n            Assert.AreEqual(typeof(BigInteger), traceReader.ValueType);\r\n            Assert.AreEqual(BigInteger.Parse(\"9999999990000000000000000000000000000000000\"), traceReader.Value);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.Null, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.Undefined, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.StartConstructor, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.Integer, traceReader.TokenType);\r\n            Assert.AreEqual(1L, traceReader.Value);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.EndConstructor, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.Comment, traceReader.TokenType);\r\n            Assert.AreEqual(\"A comment\", traceReader.Value);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.EndArray, traceReader.TokenType);\r\n\r\n            traceReader.Read();\r\n            Assert.AreEqual(JsonToken.EndObject, traceReader.TokenType);\r\n\r\n            Assert.IsFalse(traceReader.Read());\r\n\r\n            traceReader.Close();\r\n\r\n            StringAssert.AreEqual(\"Deserialized JSON: \" + Environment.NewLine + json, traceReader.GetDeserializedJsonMessage());\r\n        }\r\n#endif\r\n    }\r\n\r\n    public class TraceRecord\r\n    {\r\n        public string Message { get; set; }\r\n        public TraceLevel Level { get; set; }\r\n        public Exception Exception { get; set; }\r\n\r\n        public override string ToString()\r\n        {\r\n            return Level + \" - \" + Message;\r\n        }\r\n    }\r\n\r\n    public class InMemoryTraceWriter : ITraceWriter\r\n    {\r\n        public TraceLevel LevelFilter { get; set; }\r\n        public IList<TraceRecord> TraceRecords { get; set; }\r\n\r\n        public InMemoryTraceWriter()\r\n        {\r\n            LevelFilter = TraceLevel.Verbose;\r\n            TraceRecords = new List<TraceRecord>();\r\n        }\r\n\r\n        public void Trace(TraceLevel level, string message, Exception ex)\r\n        {\r\n            TraceRecords.Add(\r\n                new TraceRecord\r\n                {\r\n                    Level = level,\r\n                    Message = message,\r\n                    Exception = ex\r\n                });\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            StringBuilder sb = new StringBuilder();\r\n            foreach (var traceRecord in TraceRecords)\r\n            {\r\n                sb.AppendLine(traceRecord.Message);\r\n            }\r\n\r\n            return sb.ToString();\r\n        }\r\n    }\r\n\r\n    public class TraceTestObject\r\n    {\r\n        public IList<int> IntList { get; set; }\r\n        public string[] StringArray { get; set; }\r\n        public Version Version { get; set; }\r\n        public IDictionary<string, string> StringDictionary { get; set; }\r\n        public double Double { get; set; }\r\n    }\r\n\r\n    public class IntegerTestClass\r\n    {\r\n        public int Integer { get; set; }\r\n    }\r\n}",
                "test_imports": [
                    "using System;",
                    "using System.Collections.Generic;",
                    "using System.Diagnostics;",
                    "using System.Globalization;",
                    "using System.IO;",
                    "using Newtonsoft.Json.Linq;",
                    "using System.Numerics;",
                    "using System.Runtime.Serialization;",
                    "using System.Runtime.Serialization.Formatters;",
                    "using System.Text;",
                    "using NUnit.Framework;",
                    "using Newtonsoft.Json.Converters;",
                    "using Newtonsoft.Json.Serialization;",
                    "using Newtonsoft.Json.Tests.TestObjects;",
                    "using Newtonsoft.Json.Tests.TestObjects.Organization;",
                    "using Newtonsoft.Json.Utilities;",
                    "using System.Linq;"
                ],
                "test_namespace": "Newtonsoft.Json.Tests.Serialization",
                "test_class_name": "Staff",
                "test_file_path": "Newtonsoft.Json.Tests/Serialization/TraceWriterTests.cs",
                "test_runner": "NUnit",
                "project_path": "Newtonsoft.Json.Tests/Newtonsoft.Json.Tests.csproj"
            }
        ],
        "results": {
            "(code, new_tests)": [
                [],
                [],
                []
            ]
        },
        "new_tests": "using System.IO;\nusing Newtonsoft.Json.Tests.Serialization;\nusing Newtonsoft.Json;\nusing System.Numerics;\nusing Newtonsoft.Json.Tests.TestObjects;\nusing System;\nusing System.Text;\nusing Newtonsoft.Json.Linq;\nusing NUnit.Framework;\nusing System.Collections.Generic;\n\nnamespace Newtonsoft.Json.Tests.Linq\n{\n\n[TestFixture]\npublic class JTokenReaderTest\n{\n    [Test]\n    public void ReadAsDouble_Test_1()\n{\n        // Arrange\n        var json = \"3.14\";\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.AreEqual(3.14, result);\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_2()\n    {\n        // Arrange\n        var json = \"null\";\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.IsNull(result);\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_3()\n    {\n        // Arrange\n        var json = \"1.7976931348623157E+308\"; // Max double value\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.AreEqual(double.MaxValue, result);\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_4()\n    {\n        // Arrange\n        var json = \"-1.7976931348623157E+308\"; // Min double value\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.AreEqual(double.MinValue, result);\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_5()\n    {\n        // Arrange\n        var json = \"NaN\"; // Not a number\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.IsTrue(double.IsNaN(result.Value));\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_6()\n    {\n        // Arrange\n        var json = \"Infinity\"; // Positive infinity\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.AreEqual(double.PositiveInfinity, result);\n    }\n\n    [Test]\n    public void ReadAsDouble_Test_7()\n    {\n        // Arrange\n        var json = \"-Infinity\"; // Negative infinity\n        var reader = new JsonTextReader(new StringReader(json));\n        reader.Read(); // Move to the first token\n\n        // Act\n        var result = reader.ReadAsDouble();\n\n        // Assert\n        Assert.AreEqual(double.NegativeInfinity, result);\n    }\n}}",
        "new_code": "{\nif (Read())\n{\n    if (_value is string stringValue)\n    {\n        return ReadDoubleString(stringValue);\n    }\n    if (_value is double doubleValue)\n    {\n        return doubleValue;\n    }\n    if (_value is null)\n    {\n        return null;\n    }\n    throw new JsonReaderException($\"Unexpected token type: {_tokenType} for ReadAsDouble.\");\n}\nreturn null;}"
    }
]