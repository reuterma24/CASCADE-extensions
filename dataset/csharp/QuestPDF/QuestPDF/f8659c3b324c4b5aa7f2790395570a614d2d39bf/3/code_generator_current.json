{"doc": "/// <summary>\r\n/// Applies a left-to-right (LTR) content direction to all elements within the page set.\r\n/// <a href=\"https://www.questpdf.com/api-reference/content-direction.html\">Learn more</a>\r\n/// </summary>\r\n/// <include file='../Resources/Documentation.xml' path='documentation/doc[@for=\"contentDirection.rtl.remarks\"]/*'/>", "signature": {"name": "ContentFromRightToLeft", "returns": "void", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "language": "csharp", "parent": {"name": "PageDescriptor", "doc": "", "other_methods": [{"doc": "/// <summary>\r\n/// Configures the dimensions of every page within the set.\r\n/// </summary>", "signature": {"name": "Size", "returns": "void", "params": ["float width", "float height", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var pageSize = new PageSize(width, height, unit);\r\n            \r\n            MinSize(pageSize);\r\n            MaxSize(pageSize);\r\n        }"}, {"doc": "/// <summary>\r\n/// Configures the dimensions of every page within the set.\r\n/// </summary>", "signature": {"name": "Size", "returns": "void", "params": ["PageSize pageSize"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            MinSize(pageSize);\r\n            MaxSize(pageSize);\r\n        }"}, {"doc": "/// <summary>\r\n/// Enables the continuous page size mode, allowing the page's height to adjust according to content while retaining a constant specified <paramref name = \"width\"/>.\r\n/// </summary>\r\n/// <example>\r\n/// This configuration is suitable for producing PDFs intended for printing on the paper roll.\r\n/// </example>", "signature": {"name": "ContinuousSize", "returns": "void", "params": ["float width", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            MinSize(new PageSize(width.ToPoints(unit), 0));\r\n            MaxSize(new PageSize(width.ToPoints(unit), Infrastructure.Size.Max.Height));\r\n        }"}, {"doc": "/// <summary>\r\n/// Enables the flexible page size mode, where the output page's dimensions can vary based on its content.\r\n/// Specifies the smallest possible page size.\r\n/// </summary>\r\n/// <remarks>\r\n/// Note that with this setting, individual pages within the document may have different sizes.\r\n/// </remarks>", "signature": {"name": "MinSize", "returns": "void", "params": ["PageSize pageSize"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MinSize = pageSize;\r\n        }"}, {"doc": "/// <summary>\r\n/// Enables the flexible page size mode, where the output page's dimensions can vary based on its content.\r\n/// Specifies the largest possible page size.\r\n/// </summary>\r\n/// <remarks>\r\n/// Note that with this setting, individual pages within the document may have different sizes.\r\n/// </remarks>", "signature": {"name": "MaxSize", "returns": "void", "params": ["PageSize pageSize"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MaxSize = pageSize;\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space to the left of the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginLeft", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MarginLeft = value.ToPoints(unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space to the right of the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginRight", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MarginRight = value.ToPoints(unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space above the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginTop", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MarginTop = value.ToPoints(unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space below the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginBottom", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.MarginBottom = value.ToPoints(unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space vertically (top and bottom) around the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginVertical", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            MarginTop(value, unit);\r\n            MarginBottom(value, unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space horizontally (left and right) around the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "MarginHorizontal", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            MarginLeft(value, unit);\r\n            MarginRight(value, unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Adds empty space around the primary layer (header + content + footer).\r\n/// </summary>", "signature": {"name": "Margin", "returns": "void", "params": ["float value", "Unit unit = Unit.Point"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            MarginVertical(value, unit);\r\n            MarginHorizontal(value, unit);\r\n        }"}, {"doc": "/// <summary>\r\n/// Applies a default text style to all <see cref = \"TextExtensions.Text\">Text</see> elements within the page set.\r\n/// </summary>\r\n/// <remarks>\r\n/// Use this method to achieve consistent text styling across entire document.\r\n/// </remarks>\r\n/// <param name = \"handler\">A delegate to adjust the global text style attributes.</param>", "signature": {"name": "DefaultTextStyle", "returns": "void", "params": ["TextStyle textStyle"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.DefaultTextStyle = textStyle;\r\n        }"}, {"doc": "/// <summary>\r\n/// Applies a default text style to all <see cref = \"TextExtensions.Text\">Text</see> elements within the page set.\r\n/// </summary>\r\n/// <remarks>\r\n/// Use this method to achieve consistent text styling across entire document.\r\n/// </remarks>\r\n/// <param name = \"handler\">A handler to adjust the global text style attributes.</param>", "signature": {"name": "DefaultTextStyle", "returns": "void", "params": ["Func<TextStyle, TextStyle> handler"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            DefaultTextStyle(handler(TextStyle.Default));\r\n        }"}, {"doc": "/// <summary>\r\n/// Applies a left-to-right (LTR) content direction to all elements within the page set.\r\n/// <a href=\"https://www.questpdf.com/api-reference/content-direction.html\">Learn more</a>\r\n/// </summary>\r\n/// <include file='../Resources/Documentation.xml' path='documentation/doc[@for=\"contentDirection.ltr.remarks\"]/*'/>", "signature": {"name": "ContentFromLeftToRight", "returns": "void", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Page.ContentDirection = ContentDirection.LeftToRight;\r\n        }"}, {"doc": "/// <summary>\r\n/// Sets a background color of the page, which is white by default.\r\n/// </summary>\r\n/// <remarks>\r\n/// When working with file formats that support the alpha channel, it is possible to set the color to <see cref = \"Colors.Transparent\"/> if necessary.\r\n/// </remarks>\r\n/// <include file='../Resources/Documentation.xml' path='documentation/doc[@for=\"colorParam\"]/*'/>", "signature": {"name": "PageColor", "returns": "void", "params": ["string color"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            ColorValidator.Validate(color);\r\n            Page.BackgroundColor = color;\r\n        }"}, {"doc": "", "signature": {"name": "Background", "returns": "void", "params": ["string color"], "modifier": ["public"], "annotations": ["Obsolete"], "generics": []}, "code": "{\r\n            PageColor(color);\r\n        }"}, {"doc": "/// <summary>\r\n/// Represents a layer drawn behind the primary layer (header + content + footer), serving as a background.\r\n/// </summary>\r\n/// <remarks>\r\n/// Unaffected by the Margin configuration, it always occupies entire page.\r\n/// </remarks>", "signature": {"name": "Background", "returns": "IContainer", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var container = new Container();\r\n            Page.Background = container;\r\n            return container;\r\n        }"}, {"doc": "/// <summary>\r\n/// Represents a layer drawn in front of the primary layer (header + content + footer), serving as a watermark.\r\n/// </summary>\r\n/// <remarks>\r\n/// Unaffected by the Margin configuration, it always occupies entire page.\r\n/// </remarks>", "signature": {"name": "Foreground", "returns": "IContainer", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var container = new Container();\r\n            Page.Foreground = container;\r\n            return container;\r\n        }"}, {"doc": "/// <summary>\r\n/// Represents the segment at the very top of the page, just above the main content.\r\n/// </summary>\r\n/// <remarks>\r\n/// This container does not support paging capability. It's expected to be fully displayed on every page.\r\n/// </remarks>", "signature": {"name": "Header", "returns": "IContainer", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var container = new Container();\r\n            Page.Header = container;\r\n            return container;\r\n        }"}, {"doc": "/// <summary>\r\n/// Represents the primary content, located in-between the header and footer.\r\n/// </summary>\r\n/// <remarks>\r\n/// This container does support paging capability and determines the final lenght of the document.\r\n/// </remarks>", "signature": {"name": "Content", "returns": "IContainer", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var container = new Container();\r\n            Page.Content = container;\r\n            return container;\r\n        }"}, {"doc": "/// <summary>\r\n/// Represents the section at the very bottom of the page, just below the main content.\r\n/// </summary>\r\n/// <remarks>\r\n/// This container does not support paging capability. It's expected to be fully displayed on every page.\r\n/// </remarks>", "signature": {"name": "Footer", "returns": "IContainer", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var container = new Container();\r\n            Page.Footer = container;\r\n            return container;\r\n        }"}], "variables": [], "generics": [], "imports": ["using System;", "using QuestPDF.Drawing;", "using QuestPDF.Elements;", "using QuestPDF.Helpers;", "using QuestPDF.Infrastructure;"], "constructors": [], "extends": "", "implements": [""], "namespace": "QuestPDF.Fluent"}, "code": "{\r\n            Page.ContentDirection = ContentDirection.RightToLeft;\r\n        }", "code_file_path": "QuestPDF/Fluent/PageExtensions.cs", "called_functions": [], "id": 437, "tests": [{"tests": "using System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Net.Mime;\r\nusing System.Threading;\r\nusing FluentAssertions;\r\nusing NUnit.Framework;\r\nusing QuestPDF.Drawing;\r\nusing QuestPDF.Drawing.Exceptions;\r\nusing QuestPDF.Elements;\r\nusing QuestPDF.Fluent;\r\nusing QuestPDF.Helpers;\r\nusing QuestPDF.Infrastructure;\r\nusing QuestPDF.UnitTests.TestEngine;\r\nusing SkiaSharp;\r\nusing ImageElement = QuestPDF.Elements.Image;\r\nusing DocumentImage = QuestPDF.Infrastructure.Image;\r\n\r\nnamespace QuestPDF.UnitTests\r\n{\r\n    [TestFixture]\r\n    public class ImageTests\r\n    {\r\n        [Test]\r\n        public void Measure_TakesAvailableSpaceRegardlessOfSize()\r\n        {\r\n            var a = new Container();\r\n            var b = a.ContentFromLeftToRight();\r\n            var x = new AspectRatio().ContentFromRightToLeft();\r\n            ContentDirectionExtensions.ContentFromRightToLeft(new AspectRatio());\r\n\r\n            var p = new PageDescriptor();\r\n            p.ContentFromRightToLeft();\r\n\r\n            TestPlan\r\n                .For(x => new ImageElement\r\n                {\r\n                    DocumentImage = GenerateDocumentImage(400, 300)\r\n                })\r\n                .MeasureElement(new Size(300, 200))\r\n                .CheckMeasureResult(SpacePlan.FullRender(300, 200));\r\n        }\r\n\r\n        [Test]\r\n        public void Draw_TakesAvailableSpaceRegardlessOfSize()\r\n        {\r\n            TestPlan\r\n                .For(x => new ImageElement\r\n                {\r\n                    CompressionQuality = ImageCompressionQuality.High,\r\n                    TargetDpi = DocumentSettings.DefaultRasterDpi,\r\n                    DocumentImage = GenerateDocumentImage(400, 300)\r\n                })\r\n                .DrawElement(new Size(300, 200))\r\n                .ExpectCanvasDrawImage(new Position(0, 0), new Size(300, 200))\r\n                .CheckDrawResult();\r\n        }\r\n\r\n        [Test]\r\n        public void Fluent_RecognizesImageProportions()\r\n        {\r\n            var image = GenerateDocumentImage(600, 200);\r\n\r\n            TestPlan\r\n                .For(x =>\r\n                {\r\n                    var container = new Container();\r\n                    container.Image(image);\r\n                    return container;\r\n                })\r\n                .MeasureElement(new Size(300, 200))\r\n                .CheckMeasureResult(SpacePlan.FullRender(300, 100)); ;\r\n        }\r\n\r\n        [Test]\r\n        public void ImageObject_ThrowsEncodingException_WhenImageDataIsIncorrect()\r\n        {\r\n            Func<Infrastructure.Image> action = () => Infrastructure.Image.FromBinaryData(new byte[] { 1, 2, 3 });\r\n            action.Should().ThrowExactly<DocumentComposeException>().WithMessage(\"Cannot decode the provided image.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ImageObject_ThrowsEncodingException_WhenStreamIsIncorrect()\r\n        {\r\n            Func<Infrastructure.Image> action = () =>\r\n            {\r\n                using var stream = new MemoryStream(new byte[] { 1, 2, 3 });\r\n                return Infrastructure.Image.FromStream(stream);\r\n            };\r\n\r\n            action.Should().ThrowExactly<DocumentComposeException>().WithMessage(\"Cannot decode the provided image.\");\r\n        }\r\n\r\n        [Test]\r\n        public void ImageObject_ThrowsFileNotFoundException_FileIsNotFound()\r\n        {\r\n            Func<Infrastructure.Image> action = () => Infrastructure.Image.FromFile(\"non-existing-file.jpg\");\r\n            action.Should().ThrowExactly<DocumentComposeException>().WithMessage(\"Cannot load provided image, file not found: *\");\r\n        }\r\n\r\n        [Test]\r\n        public void UsingSharedImageShouldNotDrasticallyIncreaseDocumentSize()\r\n        {\r\n            var photo = File.ReadAllBytes(\"Resources/photo.jpg\");\r\n\r\n            var documentWithSingleImageSize = GetDocumentSize(container =>\r\n            {\r\n                container.Image(photo);\r\n            });\r\n\r\n            var documentWithMultipleImagesSize = GetDocumentSize(container =>\r\n            {\r\n                container.Column(column =>\r\n                {\r\n                    foreach (var i in Enumerable.Range(0, 10))\r\n                        column.Item().Image(photo);\r\n                });\r\n            });\r\n\r\n            var documentWithSingleImageUsedMultipleTimesSize = GetDocumentSize(container =>\r\n            {\r\n                container.Column(column =>\r\n                {\r\n                    var sharedImage = DocumentImage.FromBinaryData(photo);\r\n\r\n                    foreach (var i in Enumerable.Range(0, 10))\r\n                        column.Item().Image(sharedImage);\r\n                });\r\n            });\r\n\r\n            (documentWithMultipleImagesSize / (float)documentWithSingleImageSize).Should().BeInRange(9.9f, 10);\r\n            (documentWithSingleImageUsedMultipleTimesSize / (float)documentWithSingleImageSize).Should().BeInRange(1f, 1.05f);\r\n        }\r\n\r\n        [Test]\r\n        public void ImageCompressionHasImpactOnDocumentSize()\r\n        {\r\n            var photo = File.ReadAllBytes(\"Resources/photo.jpg\");\r\n\r\n            var veryLowCompressionSize = GetDocumentSize(container => container.Image(photo).WithCompressionQuality(ImageCompressionQuality.VeryLow));\r\n            var bestCompressionSize = GetDocumentSize(container => container.Image(photo).WithCompressionQuality(ImageCompressionQuality.Best));\r\n\r\n            (bestCompressionSize / (float)veryLowCompressionSize).Should().BeGreaterThan(25);\r\n        }\r\n\r\n        [Test]\r\n        public void TargetDpiHasImpactOnDocumentSize()\r\n        {\r\n            var photo = File.ReadAllBytes(\"Resources/photo.jpg\");\r\n\r\n            var lowDpiSize = GetDocumentSize(container => container.Image(photo).WithRasterDpi(12));\r\n            var highDpiSize = GetDocumentSize(container => container.Image(photo).WithRasterDpi(144));\r\n\r\n            (highDpiSize / (float)lowDpiSize).Should().BeGreaterThan(40);\r\n        }\r\n\r\n        private static int GetDocumentSize(Action<IContainer> container)\r\n        {\r\n            return Document\r\n                .Create(document =>\r\n                {\r\n                    document.Page(page =>\r\n                    {\r\n                        page.Content().Element(container);\r\n                    });\r\n                })\r\n                .GeneratePdf()\r\n                .Length;\r\n        }\r\n\r\n        DocumentImage GenerateDocumentImage(int width, int height)\r\n        {\r\n            var image = Placeholders.Image(width, height);\r\n            return DocumentImage.FromBinaryData(image);\r\n        }\r\n    }\r\n}", "test_imports": ["using System;", "using System.IO;", "using System.Linq;", "using System.Net.Mime;", "using System.Threading;", "using FluentAssertions;", "using NUnit.Framework;", "using QuestPDF.Drawing;", "using QuestPDF.Drawing.Exceptions;", "using QuestPDF.Elements;", "using QuestPDF.Fluent;", "using QuestPDF.Helpers;", "using QuestPDF.Infrastructure;", "using QuestPDF.UnitTests.TestEngine;", "using SkiaSharp;", "using ImageElement = QuestPDF.Elements.Image;", "using DocumentImage = QuestPDF.Infrastructure.Image;"], "test_namespace": "QuestPDF.UnitTests", "test_class_name": "ImageTests", "test_file_path": "QuestPDF.UnitTests/ImageTests.cs", "test_runner": "NUnit", "project_path": "QuestPDF.UnitTests/QuestPDF.UnitTests.csproj"}], "results": {"(code, new_tests)": [[], [], []]}, "new_tests": "\n[Test]\npublic void ContentFromRightToLeft_Should_SetContentDirectionToRightToLeft()\n{\n    // Arrange\n    var pageDescriptor = new PageDescriptor();\n    \n    // Act\n    pageDescriptor.ContentFromRightToLeft();\n    \n    // Assert\n    // Assuming there is a way to check the content direction, \n    // which is not shown in the provided code. \n    // This is a placeholder for the actual assertion.\n    // For example, if there is a property or method to get the current content direction:\n    // pageDescriptor.ContentDirection.Should().Be(ContentDirection.RightToLeft);\n}\n\n[Test]\npublic void ContentFromRightToLeft_Should_Not_Affect_LeftToRight_Setting()\n{\n    // Arrange\n    var pageDescriptor = new PageDescriptor();\n    pageDescriptor.ContentFromLeftToRight(); // Set LTR first\n    \n    // Act\n    pageDescriptor.ContentFromRightToLeft(); // Then set RTL\n    \n    // Assert\n    // Again, assuming there is a way to check the content direction.\n    // This is a placeholder for the actual assertion.\n    // pageDescriptor.ContentDirection.Should().Be(ContentDirection.RightToLeft);\n}\n\n[Test]\npublic void ContentFromRightToLeft_Should_Be_Idempotent()\n{\n    // Arrange\n    var pageDescriptor = new PageDescriptor();\n    pageDescriptor.ContentFromRightToLeft(); // Set RTL first\n    \n    // Act\n    pageDescriptor.ContentFromRightToLeft(); // Call again\n    \n    // Assert\n    // Assuming there is a way to check the content direction.\n    // This is a placeholder for the actual assertion.\n    // pageDescriptor.ContentDirection.Should().Be(ContentDirection.RightToLeft);\n}\n\n[Test]\npublic void ContentFromRightToLeft_Should_Allow_Sequential_Calls()\n{\n    // Arrange\n    var pageDescriptor = new PageDescriptor();\n    \n    // Act\n    pageDescriptor.ContentFromRightToLeft();\n    pageDescriptor.ContentFromRightToLeft(); // Call multiple times\n    \n    // Assert\n    // Assuming there is a way to check the content direction.\n    // This is a placeholder for the actual assertion.\n    // pageDescriptor.ContentDirection.Should().Be(ContentDirection.RightToLeft);\n}}", "response": {"id": "chatcmpl-AxZE2HzSeUByRTQMV9EvZpgBckDXM", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "```csharp\n// Set the content direction to right-to-left (RTL)\nContentDirection = ContentDirection.RightToLeft;\n\n// Apply any necessary adjustments to layout or alignment for RTL content\nforeach (var element in Elements)\n{\n    element.Alignment = Alignment.Right;\n}\n```", "role": "assistant", "function_call": null, "tool_calls": null, "refusal": null}}], "created": 1738760122, "model": "gpt-4o-mini-2024-07-18", "object": "chat.completion", "system_fingerprint": "fp_72ed7ab54c", "usage": {"completion_tokens": 55, "prompt_tokens": 1349, "total_tokens": 1404, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default"}}