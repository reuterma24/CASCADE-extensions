{"doc": "/// <summary>\n/// Gets an item associated with the specified value.\n/// </summary>\n/// <param name = \"value\">The value of the item to get.</param>\n/// <returns>\n/// The first item found that is associated with the specified value.\n/// If the specified value is not found, throws a <see cref = \"SmartEnumNotFoundException\"/>.\n/// </returns>\n/// <exception cref = \"SmartEnumNotFoundException\"><paramref name = \"value\"/> does not exist.</exception>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromValue(TValue, TEnum)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromValue(TValue, out TEnum)\"/>", "signature": {"name": "FromValue", "returns": "TEnum", "params": ["TValue value"], "modifier": ["public", "static"], "annotations": ["SuppressMessage"], "generics": []}, "language": "csharp", "parent": {"name": "SmartEnum", "doc": "/// <summary>\n/// A base type to use for creating smart enums.\n/// </summary>\n/// <typeparam name = \"TEnum\">The type that is inheriting from this class.</typeparam>\n/// <typeparam name = \"TValue\">The type of the inner value.</typeparam>\n/// <remarks></remarks>", "other_methods": [{"doc": "", "signature": {"name": "GetAllOptions", "returns": "List<TEnum>", "params": [], "modifier": ["private", "static"], "annotations": [], "generics": []}, "code": "{\n            Type baseType = typeof(TEnum);\n            return Assembly.GetAssembly(baseType)\n                .GetTypes()\n                .Where(t => baseType.IsAssignableFrom(t))\n                .SelectMany(t => t.GetFieldsOfType<TEnum>())\n                .OrderBy(t => t.Name)\n                .ToList();\n        }"}, {"doc": "", "signature": {"name": "GetValueComparer", "returns": "IEqualityComparer<TValue>", "params": [], "modifier": ["private", "static"], "annotations": [], "generics": []}, "code": "{\n            var comparer = typeof(TEnum).GetCustomAttribute<SmartEnumComparerAttribute<TValue>>();\n            return comparer?.Comparer;\n        }"}, {"doc": "/// <summary>\n/// Gets the item associated with the specified name.\n/// </summary>\n/// <param name = \"name\">The name of the item to get.</param>\n/// <param name = \"ignoreCase\"><c>true</c> to ignore case during the comparison; otherwise, <c>false</c>.</param>\n/// <returns>\n/// The item associated with the specified name.\n/// If the specified name is not found, throws a <see cref = \"KeyNotFoundException\"/>.\n/// </returns>\n/// <exception cref = \"ArgumentException\"><paramref name = \"name\"/> is <c>null</c>.</exception>\n/// <exception cref = \"SmartEnumNotFoundException\"><paramref name = \"name\"/> does not exist.</exception>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromName(string, out TEnum)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromName(string, bool, out TEnum)\"/>", "signature": {"name": "FromName", "returns": "TEnum", "params": ["string name", "bool ignoreCase = false"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": "{\n            if (String.IsNullOrEmpty(name))\n                ThrowHelper.ThrowArgumentNullOrEmptyException(nameof(name));\n\n            if (ignoreCase)\n                return FromName(_fromNameIgnoreCase.Value);\n            else\n                return FromName(_fromName.Value);\n\n            TEnum FromName(Dictionary<string, TEnum> dictionary)\n            {\n                if (!dictionary.TryGetValue(name, out var result))\n                {\n                    ThrowHelper.ThrowNameNotFoundException<TEnum, TValue>(name);\n                }\n                return result;\n            }\n        }"}, {"doc": "/// <summary>\n/// Gets the item associated with the specified name.\n/// </summary>\n/// <param name = \"name\">The name of the item to get.</param>\n/// <param name = \"result\">\n/// When this method returns, contains the item associated with the specified name, if the key is found;\n/// otherwise, <c>null</c>. This parameter is passed uninitialized.</param>\n/// <returns>\n/// <c>true</c> if the <see cref = \"SmartEnum{TEnum, TValue}\"/> contains an item with the specified name; otherwise, <c>false</c>.\n/// </returns>\n/// <exception cref = \"ArgumentException\"><paramref name = \"name\"/> is <c>null</c>.</exception>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromName(string, bool)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromName(string, bool, out TEnum)\"/>", "signature": {"name": "TryFromName", "returns": "bool", "params": ["string name", "out TEnum result"], "modifier": ["public", "static"], "annotations": ["MethodImpl"], "generics": []}, "code": ""}, {"doc": "/// <summary>\n/// Gets the item associated with the specified name.\n/// </summary>\n/// <param name = \"name\">The name of the item to get.</param>\n/// <param name = \"ignoreCase\"><c>true</c> to ignore case during the comparison; otherwise, <c>false</c>.</param>\n/// <param name = \"result\">\n/// When this method returns, contains the item associated with the specified name, if the name is found;\n/// otherwise, <c>null</c>. This parameter is passed uninitialized.</param>\n/// <returns>\n/// <c>true</c> if the <see cref = \"SmartEnum{TEnum, TValue}\"/> contains an item with the specified name; otherwise, <c>false</c>.\n/// </returns>\n/// <exception cref = \"ArgumentException\"><paramref name = \"name\"/> is <c>null</c>.</exception>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromName(string, bool)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromName(string, out TEnum)\"/>", "signature": {"name": "TryFromName", "returns": "bool", "params": ["string name", "bool ignoreCase", "out TEnum result"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": "{\n            if (String.IsNullOrEmpty(name))\n            {\n                result = default;\n                return false;\n            }\n\n            if (ignoreCase)\n                return _fromNameIgnoreCase.Value.TryGetValue(name, out result);\n            else\n                return _fromName.Value.TryGetValue(name, out result);\n        }"}, {"doc": "/// <summary>\n/// Gets an item associated with the specified value.\n/// </summary>\n/// <param name = \"value\">The value of the item to get.</param>\n/// <param name = \"defaultValue\">The value to return when item not found.</param>\n/// <returns>\n/// The first item found that is associated with the specified value.\n/// If the specified value is not found, returns <paramref name = \"defaultValue\"/>.\n/// </returns>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromValue(TValue)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.TryFromValue(TValue, out TEnum)\"/>", "signature": {"name": "FromValue", "returns": "TEnum", "params": ["TValue value", "TEnum defaultValue"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": "{\n            if (value is null)\n                ThrowHelper.ThrowArgumentNullException(nameof(value));\n\n            if (!_fromValue.Value.TryGetValue(value, out var result))\n            {\n                return defaultValue;\n            }\n            return result;\n        }"}, {"doc": "/// <summary>\n/// Gets an item associated with the specified value.\n/// </summary>\n/// <param name = \"value\">The value of the item to get.</param>\n/// <param name = \"result\">\n/// When this method returns, contains the item associated with the specified value, if the value is found;\n/// otherwise, <c>null</c>. This parameter is passed uninitialized.</param>\n/// <returns>\n/// <c>true</c> if the <see cref = \"SmartEnum{TEnum, TValue}\"/> contains an item with the specified name; otherwise, <c>false</c>.\n/// </returns>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromValue(TValue)\"/>\n/// <seealso cref = \"SmartEnum{TEnum, TValue}.FromValue(TValue, TEnum)\"/>", "signature": {"name": "TryFromValue", "returns": "bool", "params": ["TValue value", "out TEnum result"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": "{\n            if (value is null)\n            {\n                result = default;\n                return false;\n            }\n\n            return _fromValue.Value.TryGetValue(value, out result);\n        }"}, {"doc": "/// <summary>\n///\n/// </summary>\n/// <returns></returns>", "signature": {"name": "ToString", "returns": "string", "params": [], "modifier": ["public", "override"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\n///\n/// </summary>\n/// <returns></returns>", "signature": {"name": "GetHashCode", "returns": "int", "params": [], "modifier": ["public", "override"], "annotations": ["MethodImpl"], "generics": []}, "code": ""}, {"doc": "/// <summary>\n///\n/// </summary>\n/// <param name = \"obj\"></param>\n/// <returns></returns>", "signature": {"name": "Equals", "returns": "bool", "params": ["object obj"], "modifier": ["public", "override"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\n/// Returns a value indicating whether this instance is equal to a specified <see cref = \"SmartEnum{TEnum, TValue}\"/> value.\n/// </summary>\n/// <param name = \"other\">An <see cref = \"SmartEnum{TEnum, TValue}\"/> value to compare to this instance.</param>\n/// <returns><c>true</c> if <paramref name = \"other\"/> has the same value as this instance; otherwise, <c>false</c>.</returns>", "signature": {"name": "Equals", "returns": "bool", "params": ["SmartEnum<TEnum, TValue> other"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": "{\n            // check if same instance\n            if (Object.ReferenceEquals(this, other))\n                return true;\n\n            // it's not same instance so\n            // check if it's not null and is same value\n            if (other is null)\n                return false;\n\n            return _value.Equals(other._value);\n        }"}, {"doc": "/// <summary>\n/// When this instance is one of the specified <see cref = \"SmartEnum{TEnum, TValue}\"/> parameters.\n/// Execute the action in the subsequent call to Then().\n/// </summary>\n/// <param name = \"smartEnumWhen\">A collection of <see cref = \"SmartEnum{TEnum, TValue}\"/> values to compare to this instance.</param>\n/// <returns>A executor object to execute a supplied action.</returns>", "signature": {"name": "When", "returns": "SmartEnumThen<TEnum, TValue>", "params": ["SmartEnum<TEnum, TValue> smartEnumWhen"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\n/// When this instance is one of the specified <see cref = \"SmartEnum{TEnum, TValue}\"/> parameters.\n/// Execute the action in the subsequent call to Then().\n/// </summary>\n/// <param name = \"smartEnums\">A collection of <see cref = \"SmartEnum{TEnum, TValue}\"/> values to compare to this instance.</param>\n/// <returns>A executor object to execute a supplied action.</returns>", "signature": {"name": "When", "returns": "SmartEnumThen<TEnum, TValue>", "params": ["params SmartEnum<TEnum, TValue>[] smartEnums"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\n/// When this instance is one of the specified <see cref = \"SmartEnum{TEnum, TValue}\"/> parameters.\n/// Execute the action in the subsequent call to Then().\n/// </summary>\n/// <param name = \"smartEnums\">A collection of <see cref = \"SmartEnum{TEnum, TValue}\"/> values to compare to this instance.</param>\n/// <returns>A executor object to execute a supplied action.</returns>", "signature": {"name": "When", "returns": "SmartEnumThen<TEnum, TValue>", "params": ["IEnumerable<SmartEnum<TEnum, TValue>> smartEnums"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\n/// Compares this instance to a specified <see cref = \"SmartEnum{TEnum, TValue}\"/> and returns an indication of their relative values.\n/// </summary>\n/// <param name = \"other\">An <see cref = \"SmartEnum{TEnum, TValue}\"/> value to compare to this instance.</param>\n/// <returns>A signed number indicating the relative values of this instance and <paramref name = \"other\"/>.</returns>", "signature": {"name": "CompareTo", "returns": "int", "params": ["SmartEnum<TEnum, TValue> other"], "modifier": ["public", "virtual"], "annotations": ["MethodImpl"], "generics": []}, "code": ""}], "variables": ["static readonly Lazy<List<TEnum>> _enumOptions = new Lazy<List<TEnum>>(GetAllOptions, LazyThreadSafetyMode.ExecutionAndPublication);", "static readonly Lazy<Dictionary<string, TEnum>> _fromName = new Lazy<Dictionary<string, TEnum>>(() => _enumOptions.Value.ToDictionary(item => item.Name));", "static readonly Lazy<Dictionary<string, TEnum>> _fromNameIgnoreCase = new Lazy<Dictionary<string, TEnum>>(() => _enumOptions.Value.ToDictionary(item => item.Name, StringComparer.OrdinalIgnoreCase));", "static readonly Lazy<Dictionary<TValue, TEnum>> _fromValue = new Lazy<Dictionary<TValue, TEnum>>(() =>\r\n{\r\n    // multiple enums with same value are allowed but store only one per value\r\n    var dictionary = new Dictionary<TValue, TEnum>(GetValueComparer());\r\n    foreach (var item in _enumOptions.Value)\r\n    {\r\n        if (item._value is not null && !dictionary.ContainsKey(item._value))\r\n            dictionary.Add(item._value, item);\r\n    }\r\n\r\n    return dictionary;\r\n});", "private readonly string _name;", "private readonly TValue _value;"], "generics": ["TEnum", "TValue"], "imports": ["using System.Runtime.InteropServices.ComTypes;"], "constructors": ["/// <summary>\n///\n/// </summary>\n/// <param name = \"name\"></param>\n/// <param name = \"value\"></param>\nprotected SmartEnum(string name, TValue value)\r\n{\r\n    if (String.IsNullOrEmpty(name))\r\n        ThrowHelper.ThrowArgumentNullOrEmptyException(nameof(name));\r\n    _name = name;\r\n    _value = value;\r\n}"], "extends": "ISmartEnum", "implements": ["ISmartEnum", "IEquatable<SmartEnum<TEnum, TValue>>", "IComparable<SmartEnum<TEnum, TValue>>"], "namespace": "Ardalis.SmartEnum"}, "code": "{\n            TEnum result;\n\n            if (value is not null)\n            {\n                if (!_fromValue.Value.TryGetValue(value, out result))\n                {\n                    ThrowHelper.ThrowValueNotFoundException<TEnum, TValue>(value);\n                }\n            }\n            else\n            {\n                result = _enumOptions.Value.FirstOrDefault(x => x.Value is null);\n                if (result == null)\n                {\n                    ThrowHelper.ThrowValueNotFoundException<TEnum, TValue>(value);\n                }\n            }\n            return result;\n        }", "code_file_path": "src/SmartEnum/SmartEnum.cs", "called_functions": ["_fromValue.Value.TryGetValue(value, out result)", "ThrowHelper.ThrowValueNotFoundException<TEnum, TValue>(value)", "_enumOptions.Value.FirstOrDefault(x => x.Value is null)", "ThrowHelper.ThrowValueNotFoundException<TEnum, TValue>(value)"], "id": 5, "tests": [{"tests": "namespace Ardalis.SmartEnum.UnitTests\n{\n    using FluentAssertions;\n    using System;\n    using Xunit;\n\n    public class SmartEnumComparerAttribute\n    {\n        public class VanillaStringEnum : SmartEnum<VanillaStringEnum, string>\n        {\n            protected VanillaStringEnum(string name, string value) : base(name, value) { }\n\n            public static VanillaStringEnum One = new VanillaStringEnum(\"One\", \"one\");\n            public static VanillaStringEnum Two = new VanillaStringEnum(\"Two\", \"two\");\n        }\n\n        [SmartEnumStringComparer(StringComparison.InvariantCultureIgnoreCase)]\n        public class CaseInsensitiveEnum : SmartEnum<CaseInsensitiveEnum, string>\n        {\n            protected CaseInsensitiveEnum(string name, string value) : base(name, value) { }\n\n            public static CaseInsensitiveEnum One = new CaseInsensitiveEnum(\"One\", \"one\");\n            public static CaseInsensitiveEnum Two = new CaseInsensitiveEnum(\"Two\", \"two\");\n        }\n\n        [SmartEnumStringComparer(StringComparison.InvariantCulture)]\n        public class CaseSensitiveEnum : SmartEnum<CaseSensitiveEnum, string>\n        {\n            protected CaseSensitiveEnum(string name, string value) : base(name, value) { }\n\n            public static CaseSensitiveEnum One = new CaseSensitiveEnum(\"One\", \"one\");\n            public static CaseSensitiveEnum Two = new CaseSensitiveEnum(\"Two\", \"two\");\n        }\n\n        [Fact]\n        public void VanillaStringEnum_FromValue_WhenStringDoesNotMatchCase_Throws()\n        {\n            //act\n            Assert.Throws<SmartEnumNotFoundException>(() =>\n            {\n                var actual = VanillaStringEnum.FromValue(\"ONE\");\n            });\n        }\n\n        [Fact]\n        public void CaseInsensitiveEnum_FromValue_WhenStringDoesNotMatchCase_ReturnsItem()\n        {\n            //act\n            var actual = CaseInsensitiveEnum.FromValue(\"ONE\");\n\n            //assert\n            actual.Should().Be(CaseInsensitiveEnum.One);\n        }\n\n        [Fact]\n        public void CaseSensitiveEnum_FromValue_WhenStringDoesNotMatchCase_Throws()\n        {\n            //act\n            Assert.Throws<SmartEnumNotFoundException>(() =>\n            {\n                var actual = CaseSensitiveEnum.FromValue(\"ONE\");\n            });\n        }\n\n        [Fact]\n        public void VanillaStringEnum_FromValue_WhenStringMatchesCase_ReturnsItem()\n        {\n            //act\n            var actual = VanillaStringEnum.FromValue(\"one\");\n\n            //assert\n            actual.Should().Be(VanillaStringEnum.One);\n        }\n\n        [Fact]\n        public void CaseInsensitiveEnum_FromValue_WhenStringMatchesCase_ReturnsItem()\n        {\n            //act\n            var actual = CaseInsensitiveEnum.FromValue(\"one\");\n\n            //assert\n            actual.Should().Be(CaseInsensitiveEnum.One);\n        }\n\n        [Fact]\n        public void CaseSensitiveEnum_FromValue_WhenStringMatchesCase_ReturnsItem()\n        {\n            //act\n            var actual = CaseSensitiveEnum.FromValue(\"one\");\n\n            //assert\n            actual.Should().Be(CaseSensitiveEnum.One);\n        }\n    }\n}\n", "test_imports": ["using FluentAssertions;", "using System;", "using Xunit;"], "test_namespace": "Ardalis.SmartEnum.UnitTests", "test_class_name": "SmartEnumComparerAttribute", "test_file_path": "test/SmartEnum.UnitTests/SmartEnumComparerAttribute.cs", "test_runner": "xUnit", "project_path": "test/SmartEnum.UnitTests/SmartEnum.UnitTests.csproj"}, {"tests": "namespace Ardalis.SmartEnum.UnitTests\n{\n    using System;\n    using FluentAssertions;\n    using Xunit;\n\n    public class SmartEnumFromValue\n    {\n        [Fact]\n        public void ReturnsEnumGivenMatchingValue()\n        {\n            var result = TestEnum.FromValue(1);\n\n            result.Should().BeSameAs(TestEnum.One);\n        }\n\n        [Fact]\n        public void ReturnsEnumGivenDerivedClass()\n        {\n            var result = TestDerivedEnum.FromValue(1);\n\n            result.Should().NotBeNull().And.BeSameAs(TestDerivedEnum.One);\n        }\n\n        [Fact]\n        public void ThrowsGivenNonMatchingValue()\n        {\n            var value = -1;\n\n            Action action = () => TestEnum.FromValue(value);\n\n            action.Should()\n            .ThrowExactly<SmartEnumNotFoundException>()\n            .WithMessage($\"No {typeof(TestEnum).Name} with Value {value} found.\");\n\n        }\n\n        [Fact]\n        public void ReturnsDefaultEnumGivenNonMatchingValue()\n        {\n            var value = -1;\n            var defaultEnum = TestEnum.One;\n\n            var result = TestEnum.FromValue(value, defaultEnum);\n\n            result.Should().BeSameAs(defaultEnum);\n        }\n    }\n}", "test_imports": ["using System;", "using FluentAssertions;", "using Xunit;"], "test_namespace": "Ardalis.SmartEnum.UnitTests", "test_class_name": "SmartEnumFromValue", "test_file_path": "test/SmartEnum.UnitTests/SmartEnumFromValue.cs", "test_runner": "xUnit", "project_path": "test/SmartEnum.UnitTests/SmartEnum.UnitTests.csproj"}, {"tests": "namespace Ardalis.SmartEnum.UnitTests\n{\n    using FluentAssertions;\n    using System;\n    using Xunit;\n\n    public class SmartEnumStringFromValue\n    {\n        public static TheoryData<string, TestStringEnum> TestStringEnumData =>\n            new TheoryData<string, TestStringEnum>\n            {\n                { nameof(TestStringEnum.One), TestStringEnum.One },\n                { nameof(TestStringEnum.Two), TestStringEnum.Two },\n            };\n\n        [Theory]\n        [MemberData(nameof(TestStringEnumData))]\n        public void ReturnsEnumGivenMatchingValue(string value, TestStringEnum expected)\n        {\n            var result = TestStringEnum.FromValue(value);\n\n            result.Should().BeSameAs(expected);\n        }\n\n        [Fact]\n        public void ReturnsEnumGivenMatchingNullValue()\n        {\n            var result = TestNullableStringEnum.FromValue(null);\n\n            result.Should().BeSameAs(TestNullableStringEnum.None);\n        }\n\n        [Theory]\n        [InlineData(\"invalid\")]\n        [InlineData(null)]\n        public void ThrowsGivenNonMatchingValue(string value)\n        {\n            Action action = () => TestStringEnum.FromValue(value);\n\n            action.Should()\n            .ThrowExactly<SmartEnumNotFoundException>()\n            .WithMessage($\"No {typeof(TestStringEnum).Name} with Value {value} found.\");\n\n        }\n\n        [Fact]\n        public void ReturnsDefaultEnumGivenNonMatchingValue()\n        {\n            var value = \"invalid\";\n            var defaultEnum = TestStringEnum.One;\n\n            var result = TestStringEnum.FromValue(value, defaultEnum);\n\n            result.Should().BeSameAs(defaultEnum);\n        }\n\n\n        [Fact]\n        public void ReturnsDerivedEnumByValue()\n        {\n            TestBaseEnumWithDerivedValues result = DerivedTestEnumWithValues1.FromValue(1);\n\n            Assert.Equal(DerivedTestEnumWithValues1.A, result);\n        }\n    }\n}\n", "test_imports": ["using FluentAssertions;", "using System;", "using Xunit;"], "test_namespace": "Ardalis.SmartEnum.UnitTests", "test_class_name": "SmartEnumStringFromValue", "test_file_path": "test/SmartEnum.UnitTests/SmartEnumStringFromValue.cs", "test_runner": "xUnit", "project_path": "test/SmartEnum.UnitTests/SmartEnum.UnitTests.csproj"}], "results": {}, "response": {"response": {"id": "chatcmpl-AxGY7tBKGdOWxY9aygzi5ni7C3dA9", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "```csharp\n    // Arrange\n    var expectedEnum = MyEnum.Value1; // Assuming MyEnum is a derived SmartEnum with Value1 defined\n    var valueToTest = expectedEnum.Value; // Get the value associated with the expected enum\n\n    // Act\n    var result = SmartEnum<MyEnum, int>.FromValue(valueToTest);\n\n    // Assert\n    result.Should().Be(expectedEnum);\n}\n\n[Fact]\npublic void FromValue_Test_2_ValueNotFound_ReturnsDefault()\n{\n    // Arrange\n    var defaultEnum = MyEnum.Default; // Assuming MyEnum has a Default value\n    var valueToTest = 999; // A value that does not exist\n\n    // Act\n    var result = SmartEnum<MyEnum, int>.FromValue(valueToTest, defaultEnum);\n\n    // Assert\n    result.Should().Be(defaultEnum);\n}\n\n[Fact]\npublic void FromValue_Test_3_ValueNotFound_ThrowsException()\n{\n    // Arrange\n    var valueToTest = 999; // A value that does not exist\n\n    // Act\n    Action act = () => SmartEnum<MyEnum, int>.FromValue(valueToTest);\n\n    // Assert\n    act.Should().Throw<SmartEnumNotFoundException>();\n}\n\n[Fact]\npublic void FromValue_Test_4_MultipleEnumsWithSameValue_ReturnsFirst()\n{\n    // Arrange\n    var firstEnum = MyEnum.Value1; // Assuming MyEnum.Value1 has the same value as MyEnum.Value2\n    var secondEnum = MyEnum.Value2; // Assuming MyEnum.Value2 has the same value as MyEnum.Value1\n    var valueToTest = firstEnum.Value; // Get the value associated with the first enum\n\n    // Act\n    var result = SmartEnum<MyEnum, int>.FromValue(valueToTest);\n\n    // Assert\n    result.Should().Be(firstEnum); // Ensure it returns the first one\n}\n\n[Fact]\npublic void FromValue_Test_5_NullValue_ThrowsException()\n{\n    // Arrange\n    int? nullValue = null;\n\n    // Act\n    Action act = () => SmartEnum<MyEnum, int?>.FromValue(nullValue);\n\n    // Assert\n    act.Should().Throw<SmartEnumNotFoundException>();\n}\n```\n", "role": "assistant", "function_call": null, "tool_calls": null, "refusal": null}}], "created": 1738688331, "model": "gpt-4o-mini-2024-07-18", "object": "chat.completion", "system_fingerprint": "fp_bd83329f63", "usage": {"completion_tokens": 471, "prompt_tokens": 2203, "total_tokens": 2674, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default"}, "imports": {"id": "chatcmpl-AxGYKuPN0h0gz41Dk2XTJCiIYyZJ0", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "To run the provided unit tests, you will need the following using directives at the top of your test file:\n\n```csharp\nusing FluentAssertions; // For the FluentAssertions library\nusing System; // For basic types and exceptions\nusing Xunit; // For the Xunit testing framework\n```\n\nMake sure you have the necessary NuGet packages installed:\n\n1. **FluentAssertions**: This library provides a more readable way to assert conditions in your tests.\n2. **xUnit**: This is the testing framework used for writing and running the tests.\n\nYou can install these packages via the NuGet Package Manager or by using the Package Manager Console with the following commands:\n\n```bash\nInstall-Package FluentAssertions\nInstall-Package xunit\n```\n\nIf you are using a test runner that supports xUnit, such as the built-in test runner in Visual Studio or the command line, you should be able to run the tests without any additional configuration.", "role": "assistant", "function_call": null, "tool_calls": null, "refusal": null}}], "created": 1738688344, "model": "gpt-4o-mini-2024-07-18", "object": "chat.completion", "system_fingerprint": "fp_bd83329f63", "usage": {"completion_tokens": 193, "prompt_tokens": 2689, "total_tokens": 2882, "prompt_tokens_details": {"cached_tokens": 2432, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default"}}}