{"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to an output stream.\r\n/// </summary>\r\n/// <param name = \"outputStream\">The output stream of the manifest module file.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["Stream outputStream"], "modifier": ["public"], "annotations": [], "generics": []}, "language": "csharp", "parent": {"name": "ModuleDefinition", "doc": "/// <summary>\r\n/// Represents a single module in a .NET assembly. A module definition is the root object of any .NET module and\r\n/// defines types, as well as any resources and referenced assemblies.\r\n/// </summary>", "other_methods": [{"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input buffer.\r\n/// </summary>\r\n/// <param name = \"buffer\">The raw contents of the executable file to load.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromBytes", "returns": "ModuleDefinition", "params": ["byte[] buffer"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input buffer.\r\n/// </summary>\r\n/// <param name = \"buffer\">The raw contents of the executable file to load.</param>\r\n/// <param name = \"readerParameters\">The parameters to use while reading the module.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromBytes", "returns": "ModuleDefinition", "params": ["byte[] buffer", "ModuleReaderParameters readerParameters"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input file.\r\n/// </summary>\r\n/// <param name = \"filePath\">The file path to the input executable to load.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromFile", "returns": "ModuleDefinition", "params": ["string filePath"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input file.\r\n/// </summary>\r\n/// <param name = \"filePath\">The file path to the input executable to load.</param>\r\n/// <param name = \"readerParameters\">The parameters to use while reading the module.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromFile", "returns": "ModuleDefinition", "params": ["string filePath", "ModuleReaderParameters readerParameters"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input file.\r\n/// </summary>\r\n/// <param name = \"file\">The portable executable file to load.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromFile", "returns": "ModuleDefinition", "params": ["IPEFile file"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from the provided input file.\r\n/// </summary>\r\n/// <param name = \"file\">The portable executable file to load.</param>\r\n/// <param name = \"readerParameters\">The parameters to use while reading the module.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromFile", "returns": "ModuleDefinition", "params": ["IPEFile file", "ModuleReaderParameters readerParameters"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from an input stream.\r\n/// </summary>\r\n/// <param name = \"reader\">The input stream pointing at the beginning of the executable to load.</param>\r\n/// <param name = \"mode\">Indicates the input PE is mapped or unmapped.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromReader", "returns": "ModuleDefinition", "params": ["IBinaryStreamReader reader", "PEMappingMode mode = PEMappingMode.Unmapped"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Reads a .NET module from an input stream.\r\n/// </summary>\r\n/// <param name = \"reader\">The input stream pointing at the beginning of the executable to load.</param>\r\n/// <param name = \"mode\">Indicates the input PE is mapped or unmapped.</param>\r\n/// <param name = \"readerParameters\">The parameters to use while reading the module.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromReader", "returns": "ModuleDefinition", "params": ["IBinaryStreamReader reader", "PEMappingMode mode", "ModuleReaderParameters readerParameters"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Initializes a .NET module from a PE image.\r\n/// </summary>\r\n/// <param name = \"peImage\">The image containing the .NET metadata.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET metadata directory.</exception>", "signature": {"name": "FromImage", "returns": "ModuleDefinition", "params": ["IPEImage peImage"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Initializes a .NET module from a PE image.\r\n/// </summary>\r\n/// <param name = \"peImage\">The image containing the .NET metadata.</param>\r\n/// <param name = \"readerParameters\">The parameters to use while reading the module.</param>\r\n/// <returns>The module.</returns>\r\n/// <exception cref = \"BadImageFormatException\">Occurs when the image does not contain a valid .NET data directory.</exception>", "signature": {"name": "FromImage", "returns": "ModuleDefinition", "params": ["IPEImage peImage", "ModuleReaderParameters readerParameters"], "modifier": ["public", "static"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Looks up a member by its metadata token.\r\n/// </summary>\r\n/// <param name = \"token\">The token of the member to lookup.</param>\r\n/// <returns>The member.</returns>\r\n/// <exception cref = \"InvalidOperationException\">\r\n/// Occurs when the module does not support looking up members by its token.\r\n/// </exception>\r\n/// <exception cref = \"NotSupportedException\">\r\n/// Occurs when a metadata token indexes a table that cannot be converted to a metadata member.\r\n/// </exception>", "signature": {"name": "LookupMember", "returns": "IMetadataMember", "params": ["MetadataToken token"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Attempts to look up a member by its metadata token.\r\n/// </summary>\r\n/// <param name = \"token\">The token of the member to lookup.</param>\r\n/// <param name = \"member\">The member, or <c>null</c> if the lookup failed.</param>\r\n/// <returns><c>true</c> if the member was successfully looked up, false otherwise.</returns>", "signature": {"name": "TryLookupMember", "returns": "bool", "params": ["MetadataToken token", "out IMetadataMember member"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": "{\r\n            member = null;\r\n            return false;\r\n        }"}, {"doc": "/// <summary>\r\n/// Looks up a user string by its string token.\r\n/// </summary>\r\n/// <param name = \"token\">The token of the string to lookup.</param>\r\n/// <returns>The member.</returns>\r\n/// <exception cref = \"InvalidOperationException\">\r\n/// Occurs when the module does not support looking up string by its token.\r\n/// </exception>\r\n/// <exception cref = \"ArgumentOutOfRangeException\">\r\n/// Occurs when a metadata token indexes an invalid string.\r\n/// </exception>", "signature": {"name": "LookupString", "returns": "string", "params": ["MetadataToken token"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Attempts to look up a user string by its metadata token.\r\n/// </summary>\r\n/// <param name = \"token\">The token of the member to lookup.</param>\r\n/// <param name = \"value\">The string, or <c>null</c> if the lookup failed.</param>\r\n/// <returns><c>true</c> if the string was successfully looked up, false otherwise.</returns>", "signature": {"name": "TryLookupString", "returns": "bool", "params": ["MetadataToken token", "out string value"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": "{\r\n            value = null;\r\n            return false;\r\n        }"}, {"doc": "/// <summary>\r\n/// Obtains an object that can be used to decode coded indices to metadata tokens.\r\n/// </summary>\r\n/// <param name = \"codedIndex\">The type of indices to get the encoder for.</param>\r\n/// <returns>The index encoder.</returns>\r\n/// <exception cref = \"InvalidOperationException\">\r\n/// Occurs when the module does not support index encoders.\r\n/// </exception>", "signature": {"name": "GetIndexEncoder", "returns": "IndexEncoder", "params": ["CodedIndex codedIndex"], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains a list of type references that were imported into the module.\r\n/// </summary>\r\n/// <returns>The type references.</returns>\r\n/// <remarks>\r\n/// The return value of this method does not update when the <see cref = \"ReferenceImporter\"/> class is used to\r\n/// import new type references into the module. This method only serves as a way to easily get all the type\r\n/// references that were imported during the last compilation or assembly process.\r\n/// </remarks>", "signature": {"name": "GetImportedTypeReferences", "returns": "IEnumerable<TypeReference>", "params": [], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains a list of member references that were imported into the module.\r\n/// </summary>\r\n/// <returns>The type references.</returns>\r\n/// <remarks>\r\n/// The return value of this method does not update when the <see cref = \"ReferenceImporter\"/> class is used to\r\n/// import new member references into the module. This method only serves as a way to easily get all the member\r\n/// references that were imported during the last compilation or assembly process.\r\n/// </remarks>", "signature": {"name": "GetImportedMemberReferences", "returns": "IEnumerable<MemberReference>", "params": [], "modifier": ["public", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Enumerates all types (including nested types) defined in the module.\r\n/// </summary>\r\n/// <returns>The types.</returns>", "signature": {"name": "GetAllTypes", "returns": "IEnumerable<TypeDefinition>", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var agenda = new Queue<TypeDefinition>();\r\n            foreach (var type in TopLevelTypes)\r\n                agenda.Enqueue(type);\r\n\r\n            while (agenda.Count > 0)\r\n            {\r\n                var currentType = agenda.Dequeue();\r\n                yield return currentType;\r\n\r\n                foreach (var nestedType in currentType.NestedTypes)\r\n                    agenda.Enqueue(nestedType);\r\n            }\r\n        }"}, {"doc": "/// <summary>\r\n/// Gets the module static constructor of this metadata image. That is, the first method that is executed\r\n/// upon loading the .NET module.\r\n/// </summary>\r\n/// <returns>The module constructor, or <c>null</c> if none is present.</returns>", "signature": {"name": "GetModuleConstructor", "returns": "MethodDefinition", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Gets or creates the module static constructor of this metadata image. That is, the first method that is\r\n/// executed upon loading the .NET module.\r\n/// </summary>\r\n/// <returns>The module constructor.</returns>\r\n/// <remarks>\r\n/// If the static constructor was not present in the image, the new one is automatically added.\r\n/// </remarks>", "signature": {"name": "GetOrCreateModuleConstructor", "returns": "MethodDefinition", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the global scope type of the .NET module.\r\n/// </summary>\r\n/// <returns>The module type.</returns>", "signature": {"name": "GetModuleType", "returns": "TypeDefinition", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains or creates the global scope type of the .NET module.\r\n/// </summary>\r\n/// <returns>The module type.</returns>", "signature": {"name": "GetOrCreateModuleType", "returns": "TypeDefinition", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            if (TopLevelTypes.Count == 0 || TopLevelTypes[0].Name != \"<Module>\")\r\n            {\r\n                var moduleType = new TypeDefinition(null, \"<Module>\", 0);\r\n                TopLevelTypes.Insert(0, moduleType);\r\n            }\r\n\r\n            return TopLevelTypes[0];\r\n        }"}, {"doc": "/// <summary>\r\n/// Obtains the name of the module definition.\r\n/// </summary>\r\n/// <returns>The name.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"Name\"/> property.\r\n/// </remarks>", "signature": {"name": "GetName", "returns": "string", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the MVID of the module definition.\r\n/// </summary>\r\n/// <returns>The MVID.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"Mvid\"/> property.\r\n/// </remarks>", "signature": {"name": "GetMvid", "returns": "Guid", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the edit-and-continue identifier of the module definition.\r\n/// </summary>\r\n/// <returns>The identifier.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"EncId\"/> property.\r\n/// </remarks>", "signature": {"name": "GetEncId", "returns": "Guid", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the edit-and-continue base identifier of the module definition.\r\n/// </summary>\r\n/// <returns>The identifier.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"EncBaseId\"/> property.\r\n/// </remarks>", "signature": {"name": "GetEncBaseId", "returns": "Guid", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of top-level types the module defines.\r\n/// </summary>\r\n/// <returns>The types.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"TopLevelTypes\"/> property.\r\n/// </remarks>", "signature": {"name": "GetTopLevelTypes", "returns": "IList<TypeDefinition>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of references to .NET assemblies that the module uses.\r\n/// </summary>\r\n/// <returns>The references to the assemblies..</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"AssemblyReferences\"/> property.\r\n/// </remarks>", "signature": {"name": "GetAssemblyReferences", "returns": "IList<AssemblyReference>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of references to external modules that the module uses.\r\n/// </summary>\r\n/// <returns>The references to the modules.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"ModuleReferences\"/> property.\r\n/// </remarks>", "signature": {"name": "GetModuleReferences", "returns": "IList<ModuleReference>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of references to external files that the module uses.\r\n/// </summary>\r\n/// <returns>The references to the files.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"FileReferences\"/> property.\r\n/// </remarks>", "signature": {"name": "GetFileReferences", "returns": "IList<FileReference>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of resources stored in the module.\r\n/// </summary>\r\n/// <returns>The resources.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"Resources\"/> property.\r\n/// </remarks>", "signature": {"name": "GetResources", "returns": "IList<ManifestResource>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of types that are redirected to another external module.\r\n/// </summary>\r\n/// <returns>The exported types.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"ExportedTypes\"/> property.\r\n/// </remarks>", "signature": {"name": "GetExportedTypes", "returns": "IList<ExportedType>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the list of custom attributes assigned to the member.\r\n/// </summary>\r\n/// <returns>The attributes</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"CustomAttributes\"/> property.\r\n/// </remarks>", "signature": {"name": "GetCustomAttributes", "returns": "IList<CustomAttribute>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "", "signature": {"name": "GetAssembly", "returns": "AssemblyDescriptor", "params": [], "modifier": [], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the version string of the runtime.\r\n/// </summary>\r\n/// <returns>The runtime version.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"RuntimeVersion\"/> property.\r\n/// </remarks>", "signature": {"name": "GetRuntimeVersion", "returns": "string", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the managed entrypoint of this module.\r\n/// </summary>\r\n/// <returns>The entrypoint.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"ManagedEntrypoint\"/> property.\r\n/// </remarks>", "signature": {"name": "GetManagedEntrypoint", "returns": "IManagedEntrypoint", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the native win32 resources directory of the underlying PE image (if available).\r\n/// </summary>\r\n/// <returns>The resources directory.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"NativeResourceDirectory\"/> property.\r\n/// </remarks>", "signature": {"name": "GetNativeResources", "returns": "IResourceDirectory", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Obtains the native debug data directory of the underlying PE image (if available).\r\n/// </summary>\r\n/// <returns>The debug directory.</returns>\r\n/// <remarks>\r\n/// This method is called upon initialization of the <see cref = \"DebugData\"/> property.\r\n/// </remarks>", "signature": {"name": "GetDebugData", "returns": "IList<DebugDataEntry>", "params": [], "modifier": ["protected", "virtual"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Detects the runtime that this module targets.\r\n/// </summary>\r\n/// <remarks>\r\n/// This method is called to initialize the <see cref = \"OriginalTargetRuntime\"/> property.\r\n/// It should be called before the assembly resolver is initialized.\r\n/// </remarks>", "signature": {"name": "DetectTargetRuntime", "returns": "DotNetRuntimeInfo", "params": [], "modifier": ["protected"], "annotations": [], "generics": []}, "code": "{\r\n            return Assembly is not null && Assembly.TryGetTargetFramework(out var targetRuntime)\r\n                ? targetRuntime\r\n                : CorLibTypeFactory.ExtractDotNetRuntimeInfo();\r\n        }"}, {"doc": "/// <summary>\r\n/// Creates an assembly resolver based on the corlib reference.\r\n/// </summary>\r\n/// <returns>The resolver.</returns>", "signature": {"name": "CreateAssemblyResolver", "returns": "IAssemblyResolver", "params": [], "modifier": ["protected"], "annotations": [], "generics": []}, "code": "{\r\n            string fullPath = FilePath;\r\n            (string directory, string name) = !string.IsNullOrEmpty(fullPath)\r\n                ? (Path.GetDirectoryName(fullPath), Path.GetFileNameWithoutExtension(fullPath))\r\n                : (null, null);\r\n\r\n            var runtime = OriginalTargetRuntime;\r\n\r\n            AssemblyResolverBase resolver;\r\n            switch (runtime.Name)\r\n            {\r\n                case DotNetRuntimeInfo.NetFramework:\r\n                case DotNetRuntimeInfo.NetStandard\r\n                    when string.IsNullOrEmpty(DotNetCorePathProvider.DefaultInstallationPath):\r\n                    resolver = new DotNetFrameworkAssemblyResolver();\r\n                    break;\r\n                case DotNetRuntimeInfo.NetStandard\r\n                    when DotNetCorePathProvider.Default.TryGetLatestStandardCompatibleVersion(\r\n                        runtime.Version, out var coreVersion):\r\n                    resolver = new DotNetCoreAssemblyResolver(coreVersion);\r\n                    break;\r\n                case DotNetRuntimeInfo.NetCoreApp:\r\n                    resolver = new DotNetCoreAssemblyResolver(runtime.Version);\r\n                    break;\r\n                default:\r\n                    resolver = new DotNetFrameworkAssemblyResolver();\r\n                    break;\r\n            }\r\n\r\n            if (!string.IsNullOrEmpty(directory))\r\n                resolver.SearchDirectories.Add(directory);\r\n\r\n            return resolver;\r\n        }"}, {"doc": "/// <inheritdoc/>", "signature": {"name": "ToString", "returns": "string", "params": [], "modifier": ["public", "override"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to the file system.\r\n/// </summary>\r\n/// <param name = \"filePath\">The output path of the manifest module file.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["string filePath"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to the file system.\r\n/// </summary>\r\n/// <param name = \"filePath\">The output path of the manifest module file.</param>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["string filePath", "IPEImageBuilder imageBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to an output stream.\r\n/// </summary>\r\n/// <param name = \"outputStream\">The output stream of the manifest module file.</param>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["Stream outputStream", "IPEImageBuilder imageBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to the file system.\r\n/// </summary>\r\n/// <param name = \"filePath\">The output path of the manifest module file.</param>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <param name = \"fileBuilder\">The engine to use for reconstructing a PE file.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["string filePath", "IPEImageBuilder imageBuilder", "IPEFileBuilder fileBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            using var fs = File.Create(filePath);\r\n            Write(fs, imageBuilder, fileBuilder);\r\n        }"}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to an output stream.\r\n/// </summary>\r\n/// <param name = \"outputStream\">The output stream of the manifest module file.</param>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <param name = \"fileBuilder\">The engine to use for reconstructing a PE file.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["Stream outputStream", "IPEImageBuilder imageBuilder", "IPEFileBuilder fileBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            Write(new BinaryStreamWriter(outputStream), imageBuilder, fileBuilder);\r\n        }"}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and writes it to the file system.\r\n/// </summary>\r\n/// <param name = \"writer\">The output stream of the manifest module file.</param>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <param name = \"fileBuilder\">The engine to use for reconstructing a PE file.</param>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "Write", "returns": "void", "params": ["IBinaryStreamWriter writer", "IPEImageBuilder imageBuilder", "IPEFileBuilder fileBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            fileBuilder\r\n                .CreateFile(ToPEImage(imageBuilder))\r\n                .Write(writer);\r\n        }"}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and returns the IPEImage.\r\n/// </summary>\r\n/// <returns>IPEImage built using <see cref = \"ManagedPEImageBuilder\"/> by default</returns>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "ToPEImage", "returns": "IPEImage", "params": [], "modifier": ["public"], "annotations": [], "generics": []}, "code": ""}, {"doc": "/// <summary>\r\n/// Rebuilds the .NET module to a portable executable file and returns the IPEImage.\r\n/// </summary>\r\n/// <param name = \"imageBuilder\">The engine to use for reconstructing a PE image.</param>\r\n/// <returns>IPEImage built by the specified IPEImageBuilder</returns>\r\n/// <exception cref = \"AggregateException\">Occurs when the construction of the image threw exceptions.</exception>", "signature": {"name": "ToPEImage", "returns": "IPEImage", "params": ["IPEImageBuilder imageBuilder"], "modifier": ["public"], "annotations": [], "generics": []}, "code": "{\r\n            var result = imageBuilder.CreateImage(this);\r\n            if (result.DiagnosticBag.HasErrors)\r\n            {\r\n                throw new AggregateException(\r\n                    \"Construction of the PE image failed with one or more errors.\",\r\n                    result.DiagnosticBag.Exceptions);\r\n            }\r\n\r\n            return result.ConstructedImage;\r\n        }"}], "variables": ["private readonly LazyVariable<string> _name;", "private readonly LazyVariable<Guid> _mvid;", "private readonly LazyVariable<Guid> _encId;", "private readonly LazyVariable<Guid> _encBaseId;", "private IList<TypeDefinition> _topLevelTypes;", "private IList<AssemblyReference> _assemblyReferences;", "private IList<CustomAttribute> _customAttributes;", "private readonly LazyVariable<IManagedEntrypoint> _managedEntrypoint;", "private IList<ModuleReference> _moduleReferences;", "private IList<FileReference> _fileReferences;", "private IList<ManifestResource> _resources;", "private IList<ExportedType> _exportedTypes;", "private TokenAllocator _tokenAllocator;", "private readonly LazyVariable<string> _runtimeVersion;", "private readonly LazyVariable<IResourceDirectory> _nativeResources;", "private IList<DebugDataEntry> _debugData;"], "generics": [], "imports": ["using System;", "using System.Collections.Generic;", "using System.IO;", "using System.Linq;", "using System.Threading;", "using AsmResolver.Collections;", "using AsmResolver.DotNet.Builder;", "using AsmResolver.DotNet.Serialized;", "using AsmResolver.DotNet.Signatures.Types;", "using AsmResolver.PE;", "using AsmResolver.PE.Builder;", "using AsmResolver.PE.Debug;", "using AsmResolver.PE.DotNet;", "using AsmResolver.PE.DotNet.Builder;", "using AsmResolver.PE.DotNet.Metadata.Tables;", "using AsmResolver.PE.File;", "using AsmResolver.PE.File.Headers;", "using AsmResolver.PE.Win32Resources;"], "constructors": ["/// <summary>\r\n/// Initializes a new empty module with the provided metadata token.\r\n/// </summary>\r\n/// <param name = \"token\">The metadata token.</param>\r\nprotected ModuleDefinition(MetadataToken token) : base(token)\r\n{\r\n    _name = new LazyVariable<string>(GetName);\r\n    _mvid = new LazyVariable<Guid>(GetMvid);\r\n    _encId = new LazyVariable<Guid>(GetEncId);\r\n    _encBaseId = new LazyVariable<Guid>(GetEncBaseId);\r\n    _managedEntrypoint = new LazyVariable<IManagedEntrypoint>(GetManagedEntrypoint);\r\n    _runtimeVersion = new LazyVariable<string>(GetRuntimeVersion);\r\n    _nativeResources = new LazyVariable<IResourceDirectory>(GetNativeResources);\r\n    Attributes = DotNetDirectoryFlags.ILOnly;\r\n}", "/// <summary>\r\n/// Defines a new .NET module that references mscorlib version 4.0.0.0.\r\n/// </summary>\r\n/// <param name = \"name\">The name of the module.</param>\r\npublic ModuleDefinition(string name) : this(new MetadataToken(TableIndex.Module, 0))\r\n{\r\n    Name = name;\r\n    CorLibTypeFactory = CorLibTypeFactory.CreateMscorlib40TypeFactory(this);\r\n    AssemblyReferences.Add((AssemblyReference)CorLibTypeFactory.CorLibScope);\r\n    MetadataResolver = new DefaultMetadataResolver(new DotNetFrameworkAssemblyResolver());\r\n    TopLevelTypes.Add(new TypeDefinition(null, \"<Module>\", 0));\r\n}", "/// <summary>\r\n/// Defines a new .NET module.\r\n/// </summary>\r\n/// <param name = \"name\">The name of the module.</param>\r\n/// <param name = \"corLib\">The reference to the common object runtime (COR) library that this module will use.</param>\r\npublic ModuleDefinition(string name, AssemblyReference corLib) : this(new MetadataToken(TableIndex.Module, 0))\r\n{\r\n    Name = name;\r\n    var importer = new ReferenceImporter(this);\r\n    corLib = (AssemblyReference)importer.ImportScope(corLib);\r\n    CorLibTypeFactory = new CorLibTypeFactory(corLib);\r\n    AssemblyReferences.Add(corLib);\r\n    OriginalTargetRuntime = DetectTargetRuntime();\r\n    MetadataResolver = new DefaultMetadataResolver(CreateAssemblyResolver());\r\n    TopLevelTypes.Add(new TypeDefinition(null, \"<Module>\", 0));\r\n}"], "extends": "MetadataMember", "implements": ["MetadataMember", "IResolutionScope", "IHasCustomAttribute", "IOwnedCollectionElement<AssemblyDefinition>"], "namespace": "AsmResolver.DotNet"}, "code": "", "code_file_path": "src/AsmResolver.DotNet/ModuleDefinition.cs", "called_functions": [], "id": 2007, "tests": [{"tests": "using System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.Builder;\r\nusing AsmResolver.DotNet.Builder.Metadata;\r\nusing AsmResolver.PE;\r\nusing AsmResolver.PE.DotNet.Metadata;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables;\r\nusing Xunit;\r\n\r\nnamespace AsmResolver.DotNet.Tests.Builder\r\n{\r\n    public class ManagedPEImageBuilderTest\r\n    {\r\n        [Fact]\r\n        public void ExecutableImportDirectoryShouldContainMsCoreeCorExeMain()\r\n        {\r\n            using var stream = new MemoryStream();\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters);\r\n            module.Write(stream);\r\n\r\n            var image = PEImage.FromBytes(stream.ToArray());\r\n            var symbol = image\r\n                .Imports.FirstOrDefault(m => m.Name == \"mscoree.dll\")\r\n                ?.Symbols.FirstOrDefault(m => m.Name == \"_CorExeMain\");\r\n\r\n            Assert.NotNull(symbol);\r\n            Assert.Contains(image.Relocations, relocation =>\r\n                relocation.Location.CanRead\r\n                && relocation.Location.CreateReader().ReadUInt32() == image.ImageBase + symbol.AddressTableEntry!.Rva);\r\n        }\r\n\r\n        [Fact]\r\n        public void ExecutableImportDirectoryShouldContainMsCoreeCorDllMain()\r\n        {\r\n            using var stream = new MemoryStream();\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.ForwarderLibrary, TestReaderParameters);\r\n            module.Write(stream);\r\n\r\n            var image = PEImage.FromBytes(stream.ToArray());\r\n            var symbol = image\r\n                .Imports.FirstOrDefault(m => m.Name == \"mscoree.dll\")\r\n                ?.Symbols.FirstOrDefault(m => m.Name == \"_CorDllMain\");\r\n\r\n            Assert.NotNull(symbol);\r\n            Assert.Contains(image.Relocations, relocation =>\r\n                relocation.Location.CanRead\r\n                && relocation.Location.CreateReader().ReadUInt32() == image.ImageBase + symbol.AddressTableEntry!.Rva);\r\n        }\r\n\r\n        [Fact]\r\n        public void ConstructPEImageFromNewModuleWithNoPreservation()\r\n        {\r\n            var module = new ModuleDefinition(\"Module\");\r\n            var result = module.ToPEImage();\r\n            var newModule = ModuleDefinition.FromImage(result, TestReaderParameters);\r\n            Assert.Equal(module.Name, newModule.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void ConstructPEImageFromNewModuleWithPreservation()\r\n        {\r\n            var module = new ModuleDefinition(\"Module\");\r\n            var result = module.ToPEImage(new ManagedPEImageBuilder(MetadataBuilderFlags.PreserveAll));\r\n            var newModule = ModuleDefinition.FromImage(result, TestReaderParameters);\r\n            Assert.Equal(module.Name, newModule.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void ConstructPEImageFromExistingModuleWithNoPreservation()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters);\r\n            var result = module.ToPEImage();\r\n            var newModule = ModuleDefinition.FromImage(result, TestReaderParameters);\r\n            Assert.Equal(module.Name, newModule.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void ConstructPEImageFromExistingModuleWithPreservation()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters);\r\n            var result = module.ToPEImage(new ManagedPEImageBuilder(MetadataBuilderFlags.PreserveAll));\r\n            var newModule = ModuleDefinition.FromImage(result, TestReaderParameters);\r\n            Assert.Equal(module.Name, newModule.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void PreserveUnknownStreams()\r\n        {\r\n            // Prepare a PE image with an extra unconventional stream.\r\n            var image = PEImage.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters.PEReaderParameters);\r\n            byte[] data = { 1, 2, 3, 4 };\r\n            image.DotNetDirectory!.Metadata!.Streams.Add(new CustomMetadataStream(\"#Custom\", data));\r\n\r\n            // Load and rebuild.\r\n            var module = ModuleDefinition.FromImage(image, TestReaderParameters);\r\n            var newImage = module.ToPEImage(new ManagedPEImageBuilder(MetadataBuilderFlags.PreserveUnknownStreams));\r\n\r\n            // Verify unconventional stream is still present.\r\n            var newStream = Assert.IsAssignableFrom<CustomMetadataStream>(\r\n                newImage.DotNetDirectory!.Metadata!.GetStream(\"#Custom\"));\r\n            Assert.Equal(data, Assert.IsAssignableFrom<IReadableSegment>(newStream.Contents).ToArray());\r\n        }\r\n\r\n        [Fact]\r\n        public void PreserveStreamOrder()\r\n        {\r\n            // Prepare a PE image with an unconventional stream order.\r\n            var image = PEImage.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters.PEReaderParameters);\r\n            var streams = image.DotNetDirectory!.Metadata!.Streams;\r\n            for (int i = 0; i < streams.Count / 2; i++)\r\n                (streams[i], streams[streams.Count - i - 1]) = (streams[streams.Count - i - 1], streams[i]);\r\n\r\n            // Load and rebuild.\r\n            var module = ModuleDefinition.FromImage(image, TestReaderParameters);\r\n            var newImage = module.ToPEImage(new ManagedPEImageBuilder(MetadataBuilderFlags.PreserveStreamOrder));\r\n\r\n            // Verify order is still the same.\r\n            Assert.Equal(\r\n                streams.Select(x => x.Name),\r\n                newImage.DotNetDirectory!.Metadata!.Streams.Select(x => x.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void PreserveUnknownStreamsAndStreamOrder()\r\n        {\r\n            // Prepare a PE image with an unconventional stream order and custom stream.\r\n            var image = PEImage.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters.PEReaderParameters);\r\n            var streams = image.DotNetDirectory!.Metadata!.Streams;\r\n\r\n            for (int i = 0; i < streams.Count / 2; i++)\r\n                (streams[i], streams[streams.Count - i - 1]) = (streams[streams.Count - i - 1], streams[i]);\r\n\r\n            byte[] data = { 1, 2, 3, 4 };\r\n            image.DotNetDirectory!.Metadata!.Streams.Insert(streams.Count / 2,\r\n                new CustomMetadataStream(\"#Custom\", data));\r\n\r\n            // Load and rebuild.\r\n            var module = ModuleDefinition.FromImage(image, TestReaderParameters);\r\n            var newImage = module.ToPEImage(new ManagedPEImageBuilder(\r\n                MetadataBuilderFlags.PreserveStreamOrder | MetadataBuilderFlags.PreserveUnknownStreams));\r\n\r\n            // Verify order is still the same.\r\n            Assert.Equal(\r\n                streams.Select(x => x.Name),\r\n                newImage.DotNetDirectory!.Metadata!.Streams.Select(x => x.Name));\r\n\r\n            // Verify unconventional stream is still present.\r\n            var newStream = Assert.IsAssignableFrom<CustomMetadataStream>(\r\n                newImage.DotNetDirectory!.Metadata!.GetStream(\"#Custom\"));\r\n            Assert.Equal(data, Assert.IsAssignableFrom<IReadableSegment>(newStream.Contents).ToArray());\r\n        }\r\n\r\n        [Fact]\r\n        public void BuildInvalidImageShouldRegisterDiagnostics()\r\n        {\r\n            // Prepare temp assembly.\r\n            var assembly = new AssemblyDefinition(\"Assembly\", new Version(1, 0, 0, 0));\r\n            var module = new ModuleDefinition(\"Module\");\r\n            assembly.Modules.Add(module);\r\n\r\n            // Add some field with an non-imported field type.\r\n            module.GetOrCreateModuleType().Fields.Add(new FieldDefinition(\r\n                \"Field\",\r\n                FieldAttributes.Static,\r\n                new TypeReference(null, \"NonImportedNamespace\", \"NonImportedType\").ToTypeSignature()));\r\n\r\n            // Build.\r\n            var bag = new DiagnosticBag();\r\n            var image = module.ToPEImage(new ManagedPEImageBuilder(bag), false);\r\n\r\n            // Verify diagnostics.\r\n            Assert.NotNull(image);\r\n            Assert.Contains(bag.Exceptions, x => x is MemberNotImportedException);\r\n        }\r\n\r\n        [Fact]\r\n        public void BuildingImageShouldConsiderJTDStreamAndUseLargeColumns()\r\n        {\r\n            var moduleDefinition = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld_JTDStream, TestReaderParameters);\r\n            var metadata = moduleDefinition.DotNetDirectory!.Metadata!;\r\n\r\n            Assert.True(metadata.IsEncMetadata);\r\n            Assert.True(metadata.GetStream<TablesStream>().ForceLargeColumns);\r\n\r\n            var builder = new ManagedPEImageBuilder(MetadataBuilderFlags.PreserveAll | MetadataBuilderFlags.ForceEncMetadata);\r\n            var rebuiltImage = moduleDefinition.ToPEImage(builder);\r\n            var rebuiltMetadata = rebuiltImage.DotNetDirectory!.Metadata!;\r\n\r\n            Assert.True(rebuiltMetadata.IsEncMetadata);\r\n            Assert.True(rebuiltMetadata.GetStream<TablesStream>().ForceLargeColumns);\r\n        }\r\n    }\r\n}\r\n", "test_imports": ["using System;", "using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.Builder;", "using AsmResolver.DotNet.Builder.Metadata;", "using AsmResolver.PE;", "using AsmResolver.PE.DotNet.Metadata;", "using AsmResolver.PE.DotNet.Metadata.Tables;", "using Xunit;"], "test_namespace": "AsmResolver.DotNet.Tests.Builder", "test_class_name": "ManagedPEImageBuilderTest", "test_file_path": "test/AsmResolver.DotNet.Tests/Builder/ManagedPEImageBuilderTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.TestCases.Fields;\r\nusing Xunit;\r\n\r\nnamespace AsmResolver.DotNet.Tests\r\n{\r\n    public class ConstantTest\r\n    {\r\n        private Constant GetFieldConstant(string name)\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(Constants).Assembly.Location);\r\n            return GetFieldConstantInModule(module, name);\r\n        }\r\n\r\n        private static Constant GetFieldConstantInModule(ModuleDefinition module, string name)\r\n        {\r\n            var t = module.TopLevelTypes.First(t => t.Name == nameof(Constants));\r\n            return t.Fields.First(f => f.Name == name).Constant;\r\n        }\r\n\r\n        private Constant RebuildAndLookup(ModuleDefinition module, string name)\r\n        {\r\n            string tempFile = Path.GetTempFileName();\r\n            module.Write(tempFile);\r\n            \r\n            var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            \r\n            var newModule = ModuleDefinition.FromBytes(stream.ToArray());\r\n            return GetFieldConstantInModule(newModule, name);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(nameof(Constants.Boolean), Constants.Boolean)]\r\n        [InlineData(nameof(Constants.Byte), Constants.Byte)]\r\n        [InlineData(nameof(Constants.UInt16), Constants.UInt16)]\r\n        [InlineData(nameof(Constants.UInt32), Constants.UInt32)]\r\n        [InlineData(nameof(Constants.UInt64), Constants.UInt64)]\r\n        [InlineData(nameof(Constants.SByte), Constants.SByte)]\r\n        [InlineData(nameof(Constants.Int16), Constants.Int16)]\r\n        [InlineData(nameof(Constants.Int32), Constants.Int32)]\r\n        [InlineData(nameof(Constants.Int64), Constants.Int64)]\r\n        [InlineData(nameof(Constants.Single), Constants.Single)]\r\n        [InlineData(nameof(Constants.Double), Constants.Double)]\r\n        [InlineData(nameof(Constants.Char), Constants.Char)]\r\n        [InlineData(nameof(Constants.String), Constants.String)]\r\n        public void ReadAndInterpretData(string name, object expected)\r\n        {\r\n            var constant = GetFieldConstant(name);\r\n            Assert.Equal(expected, constant.Value.InterpretData(constant.Type));\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(nameof(Constants.Boolean))]\r\n        [InlineData(nameof(Constants.Byte))]\r\n        [InlineData(nameof(Constants.UInt16))]\r\n        [InlineData(nameof(Constants.UInt32))]\r\n        [InlineData(nameof(Constants.UInt64))]\r\n        [InlineData(nameof(Constants.SByte))]\r\n        [InlineData(nameof(Constants.Int16))]\r\n        [InlineData(nameof(Constants.Int32))]\r\n        [InlineData(nameof(Constants.Int64))]\r\n        [InlineData(nameof(Constants.Single))]\r\n        [InlineData(nameof(Constants.Double))]\r\n        [InlineData(nameof(Constants.Char))]\r\n        [InlineData(nameof(Constants.String))]\r\n        public void PersistentConstants(string name)\r\n        {\r\n            var constant = GetFieldConstant(name);\r\n            var newConstant = RebuildAndLookup(constant.Parent.Module, name);\r\n            Assert.NotNull(newConstant);\r\n            Assert.Equal(constant.Value.Data, newConstant.Value.Data);\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadInvalidConstantValueShouldNotThrow()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.ConstantZeroValueColumn);\r\n            var constantValue = module\r\n                .TopLevelTypes.First(t => t.Name == \"MyClass\")\r\n                .Fields.First(f => f.Name == \"MyIntegerConstant\")\r\n                .Constant.Value;\r\n            Assert.Null(constantValue);\r\n        }\r\n\r\n        [Fact]\r\n        public void WriteNullConstantValueShouldNotThrow()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.ConstantZeroValueColumn);\r\n            \r\n            var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            \r\n            var newModule = ModuleDefinition.FromBytes(stream.ToArray());\r\n            \r\n            var constantValue = newModule\r\n                .TopLevelTypes.First(t => t.Name == \"MyClass\")\r\n                .Fields.First(f => f.Name == \"MyIntegerConstant\")\r\n                .Constant.Value;\r\n            Assert.Null(constantValue);\r\n        }\r\n        \r\n    }\r\n}", "test_imports": ["using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.TestCases.Fields;", "using Xunit;"], "test_namespace": "AsmResolver.DotNet.Tests", "test_class_name": "ConstantTest", "test_file_path": "test/AsmResolver.DotNet.Tests/ConstantTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.Builder;\r\nusing AsmResolver.DotNet.Code.Cil;\r\nusing AsmResolver.DotNet.Signatures;\r\nusing AsmResolver.DotNet.Signatures.Types;\r\nusing AsmResolver.DotNet.TestCases.CustomAttributes;\r\nusing AsmResolver.DotNet.TestCases.Properties;\r\nusing AsmResolver.PE;\r\nusing AsmResolver.PE.DotNet.Cil;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables.Rows;\r\nusing Xunit;\r\n\r\nnamespace AsmResolver.DotNet.Tests\r\n{\r\n    public class CustomAttributeTest\r\n    {\r\n        private readonly SignatureComparer _comparer = new SignatureComparer();\r\n        \r\n        [Fact]\r\n        public void ReadConstructor()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(CustomAttributesTestClass).Assembly.Location);\r\n            var type = module.TopLevelTypes.First(t => t.Name == nameof(CustomAttributesTestClass));\r\n\r\n            Assert.All(type.CustomAttributes, a =>\r\n                Assert.Equal(nameof(TestCaseAttribute), a.Constructor.DeclaringType.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentConstructor()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(CustomAttributesTestClass).Assembly.Location);\r\n            using var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            \r\n            module = ModuleDefinition.FromReader(new ByteArrayReader(stream.ToArray()));\r\n            \r\n            var type = module.TopLevelTypes.First(t => t.Name == nameof(CustomAttributesTestClass));\r\n            Assert.All(type.CustomAttributes, a =>\r\n                Assert.Equal(nameof(TestCaseAttribute), a.Constructor.DeclaringType.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadParent()\r\n        {\r\n            int parentToken = typeof(CustomAttributesTestClass).MetadataToken;\r\n            string filePath = typeof(CustomAttributesTestClass).Assembly.Location;\r\n\r\n            var image = PEImage.FromFile(filePath);\r\n            var tablesStream = image.DotNetDirectory.Metadata.GetStream<TablesStream>();\r\n            var encoder = tablesStream.GetIndexEncoder(CodedIndex.HasCustomAttribute);\r\n            var attributeTable = tablesStream.GetTable<CustomAttributeRow>(TableIndex.CustomAttribute);\r\n\r\n            // Find token of custom attribute\r\n            var attributeToken = MetadataToken.Zero;\r\n            for (int i = 0; i < attributeTable.Count && attributeToken == 0; i++)\r\n            {\r\n                var row = attributeTable[i];\r\n                var token = encoder.DecodeIndex(row.Parent);\r\n                if (token == parentToken)\r\n                    attributeToken = new MetadataToken(TableIndex.CustomAttribute, (uint) (i + 1));\r\n            }\r\n\r\n            // Resolve by token and verify parent (forcing parent to execute the lazy initialization ).\r\n            var module = ModuleDefinition.FromFile(filePath);\r\n            var attribute = (CustomAttribute) module.LookupMember(attributeToken);\r\n            Assert.NotNull(attribute.Parent);\r\n            Assert.IsAssignableFrom<TypeDefinition>(attribute.Parent);\r\n            Assert.Equal(parentToken, attribute.Parent.MetadataToken);\r\n        }\r\n\r\n        private static CustomAttribute GetCustomAttributeTestCase(string methodName, bool rebuild = false)\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(CustomAttributesTestClass).Assembly.Location);\r\n            var type = module.TopLevelTypes.First(t => t.Name == nameof(CustomAttributesTestClass));\r\n            var method = type.Methods.First(m => m.Name == methodName);\r\n            var attribute = method.CustomAttributes\r\n                .First(c => c.Constructor.DeclaringType.Name == nameof(TestCaseAttribute));\r\n            \r\n            if (rebuild)\r\n                attribute = RebuildAndLookup(attribute);\r\n            return attribute;\r\n        }\r\n\r\n        private static CustomAttribute RebuildAndLookup(CustomAttribute attribute)\r\n        {\r\n            var stream = new MemoryStream();\r\n            var method = (MethodDefinition) attribute.Parent;\r\n            method.Module.Write(stream);\r\n            var newModule = ModuleDefinition.FromBytes(stream.ToArray());\r\n\r\n            return newModule\r\n                .TopLevelTypes.First(t => t.FullName == method.DeclaringType.FullName)\r\n                .Methods.First(f => f.Name == method.Name)\r\n                .CustomAttributes[0];\r\n        }\r\n        \r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32Argument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32Argument), rebuild);\r\n            \r\n            Assert.Single(attribute.Signature.FixedArguments);\r\n            Assert.Empty(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n            Assert.Equal(1, argument.Element);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedStringArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedStringArgument), rebuild);\r\n            Assert.Single(attribute.Signature.FixedArguments);\r\n            Assert.Empty(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n            Assert.Equal(\"String fixed arg\", argument.Element);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedEnumArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedEnumArgument), rebuild);\r\n            Assert.Single(attribute.Signature.FixedArguments);\r\n            Assert.Empty(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n            Assert.Equal((int) TestEnum.Value3, argument.Element);\r\n        }\r\n        \r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedTypeArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedTypeArgument), rebuild);\r\n            Assert.Single(attribute.Signature.FixedArguments);\r\n            Assert.Empty(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n            Assert.Equal(\r\n                attribute.Constructor.Module.CorLibTypeFactory.String, \r\n                argument.Element as TypeSignature, _comparer);\r\n        }\r\n        \r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedComplexTypeArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedComplexTypeArgument), rebuild);\r\n            Assert.Single(attribute.Signature.FixedArguments);\r\n            Assert.Empty(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n            var factory = attribute.Constructor.Module.CorLibTypeFactory;\r\n            \r\n            var listRef = new TypeReference(factory.CorLibScope, \"System.Collections.Generic\", \"KeyValuePair`2\");\r\n            var instance = new GenericInstanceTypeSignature(listRef, false,\r\n                new SzArrayTypeSignature(factory.String),\r\n                new SzArrayTypeSignature(factory.Int32));\r\n\r\n            Assert.Equal(instance, argument.Element as TypeSignature, _comparer);\r\n        }\r\n        \r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void NamedInt32Argument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.NamedInt32Argument), rebuild);\r\n            Assert.Empty(attribute.Signature.FixedArguments);\r\n            Assert.Single(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.NamedArguments[0];\r\n            Assert.Equal(nameof(TestCaseAttribute.IntValue), argument.MemberName);\r\n            Assert.Equal(2, argument.Argument.Element);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void NamedStringArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.NamedStringArgument), rebuild);\r\n            Assert.Empty(attribute.Signature.FixedArguments);\r\n            Assert.Single(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.NamedArguments[0];\r\n            Assert.Equal(nameof(TestCaseAttribute.StringValue), argument.MemberName);\r\n            Assert.Equal(\"String named arg\", argument.Argument.Element);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void NamedEnumArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.NamedEnumArgument), rebuild);\r\n            Assert.Empty(attribute.Signature.FixedArguments);\r\n            Assert.Single(attribute.Signature.NamedArguments);\r\n\r\n            var argument = attribute.Signature.NamedArguments[0];\r\n            Assert.Equal(nameof(TestCaseAttribute.EnumValue), argument.MemberName);\r\n            Assert.Equal((int) TestEnum.Value2, argument.Argument.Element);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void NamedTypeArgument(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.NamedTypeArgument), rebuild);\r\n            Assert.Empty(attribute.Signature.FixedArguments);\r\n            Assert.Single(attribute.Signature.NamedArguments);\r\n\r\n            var expected = new TypeReference(\r\n                attribute.Constructor.Module.CorLibTypeFactory.CorLibScope,\r\n                \"System\", \"Int32\");\r\n            \r\n            var argument = attribute.Signature.NamedArguments[0];\r\n            Assert.Equal(nameof(TestCaseAttribute.TypeValue), argument.MemberName);\r\n            Assert.Equal(expected, (ITypeDescriptor) argument.Argument.Element, _comparer);\r\n        }\r\n\r\n        [Fact]\r\n        public void IsCompilerGeneratedMember()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(SingleProperty).Assembly.Location);\r\n            var type = module.TopLevelTypes.First(t => t.Name == nameof(SingleProperty));\r\n            var property = type.Properties.First();\r\n            var setMethod = property.SetMethod;\r\n\r\n            Assert.True(setMethod.IsCompilerGenerated());\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void GenericTypeArgument(bool rebuild)\r\n        {\r\n            // https://github.com/Washi1337/AsmResolver/issues/92\r\n            \r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.GenericType), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            var module = attribute.Constructor.Module;\r\n            var nestedClass = (TypeDefinition) module.LookupMember(typeof(TestGenericType<>).MetadataToken);\r\n            var expected = new GenericInstanceTypeSignature(nestedClass, false, module.CorLibTypeFactory.Object);\r\n            \r\n            Assert.IsAssignableFrom<TypeSignature>(argument.Element);\r\n            Assert.Equal(expected, (TypeSignature) argument.Element, _comparer);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void ArrayGenericTypeArgument(bool rebuild)\r\n        {\r\n            // https://github.com/Washi1337/AsmResolver/issues/92\r\n            \r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.GenericTypeArray), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            var module = attribute.Constructor.Module;\r\n            var nestedClass = (TypeDefinition) module.LookupMember(typeof(TestGenericType<>).MetadataToken);\r\n            var expected = new SzArrayTypeSignature(\r\n                new GenericInstanceTypeSignature(nestedClass, false, module.CorLibTypeFactory.Object)\r\n            );\r\n\r\n            Assert.IsAssignableFrom<TypeSignature>(argument.Element);\r\n            Assert.Equal(expected, (TypeSignature) argument.Element, _comparer);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void IntPassedOnAsObject(bool rebuild)\r\n        {\r\n            // https://github.com/Washi1337/AsmResolver/issues/92\r\n            \r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.Int32PassedAsObject), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.IsAssignableFrom<BoxedArgument>(argument.Element);\r\n            Assert.Equal(123, ((BoxedArgument) argument.Element).Value);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void TypePassedOnAsObject(bool rebuild)\r\n        {\r\n            // https://github.com/Washi1337/AsmResolver/issues/92\r\n            \r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.TypePassedAsObject), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            var module = attribute.Constructor.Module;\r\n            Assert.IsAssignableFrom<BoxedArgument>(argument.Element);\r\n            Assert.Equal(module.CorLibTypeFactory.Int32, (ITypeDescriptor) ((BoxedArgument) argument.Element).Value, _comparer);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32NullArray(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayNullArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.True(argument.IsNullArray);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32EmptyArray(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayEmptyArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.False(argument.IsNullArray);\r\n            Assert.Empty(argument.Elements);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32Array(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.Equal(new[]\r\n            {\r\n                1, 2, 3, 4\r\n            }, argument.Elements.Cast<int>());\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32ArrayNullAsObject(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayAsObjectNullArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.IsAssignableFrom<BoxedArgument>(argument.Element);\r\n            var boxedArgument = (BoxedArgument) argument.Element;\r\n            Assert.Null(boxedArgument.Value);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32EmptyArrayAsObject(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayAsObjectEmptyArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.IsAssignableFrom<BoxedArgument>(argument.Element);\r\n            var boxedArgument = (BoxedArgument) argument.Element;\r\n            Assert.Equal(new object[0], boxedArgument.Value);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void FixedInt32ArrayAsObject(bool rebuild)\r\n        {\r\n            var attribute = GetCustomAttributeTestCase(nameof(CustomAttributesTestClass.FixedInt32ArrayAsObjectArgument), rebuild);\r\n            var argument = attribute.Signature.FixedArguments[0];\r\n\r\n            Assert.IsAssignableFrom<BoxedArgument>(argument.Element);\r\n            var boxedArgument = (BoxedArgument) argument.Element;\r\n            Assert.Equal(new[]\r\n            {\r\n                1, 2, 3, 4\r\n            }, boxedArgument.Value);\r\n        }\r\n    }\r\n}", "test_imports": ["using System;", "using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.Builder;", "using AsmResolver.DotNet.Code.Cil;", "using AsmResolver.DotNet.Signatures;", "using AsmResolver.DotNet.Signatures.Types;", "using AsmResolver.DotNet.TestCases.CustomAttributes;", "using AsmResolver.DotNet.TestCases.Properties;", "using AsmResolver.PE;", "using AsmResolver.PE.DotNet.Cil;", "using AsmResolver.PE.DotNet.Metadata.Tables;", "using AsmResolver.PE.DotNet.Metadata.Tables.Rows;", "using Xunit;"], "test_namespace": "AsmResolver.DotNet.Tests", "test_class_name": "CustomAttributeTest", "test_file_path": "test/AsmResolver.DotNet.Tests/CustomAttributeTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables.Rows;\r\nusing Xunit;\r\nusing TestCaseResources = AsmResolver.DotNet.TestCases.Resources.Resources;\r\n\r\nnamespace AsmResolver.DotNet.Tests\r\n{\r\n    public class ManifestResourceTest\r\n    {\r\n        [Fact]\r\n        public void ReadEmbeddedResource1Data()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(TestCaseResources).Assembly.Location);\r\n            var resource = module.Resources.First(r =>\r\n                r.Name == \"AsmResolver.DotNet.TestCases.Resources.Resources.EmbeddedResource1\");\r\n\r\n            Assert.Equal(TestCaseResources.GetEmbeddedResource1Data(), Encoding.ASCII.GetString(resource.GetData()));\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadEmbeddedResource2Data()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(TestCaseResources).Assembly.Location);\r\n            var resource = module.Resources.First(r =>\r\n                r.Name == \"AsmResolver.DotNet.TestCases.Resources.Resources.EmbeddedResource2\");\r\n\r\n            Assert.Equal(TestCaseResources.GetEmbeddedResource2Data(), Encoding.ASCII.GetString(resource.GetData()));\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentData()\r\n        {\r\n            const string resourceName = \"SomeResource\";\r\n            var contents = new byte[]\r\n            {\r\n                0,1,2,3,4\r\n            };\r\n            \r\n            var module = ModuleDefinition.FromFile(typeof(TestCaseResources).Assembly.Location);\r\n            module.Resources.Add(new ManifestResource(resourceName, ManifestResourceAttributes.Public, new DataSegment(contents)));\r\n            \r\n            using var stream = new MemoryStream();\r\n            module.Write(stream);\r\n\r\n            var newModule = ModuleDefinition.FromBytes(stream.ToArray());\r\n            Assert.Equal(contents, newModule.Resources.First(r => r.Name == resourceName).GetData());\r\n        }\r\n    }\r\n}", "test_imports": ["using System.IO;", "using System.Linq;", "using System.Text;", "using AsmResolver.PE.DotNet.Metadata.Tables.Rows;", "using Xunit;", "using TestCaseResources = AsmResolver.DotNet.TestCases.Resources.Resources;"], "test_namespace": "AsmResolver.DotNet.Tests", "test_class_name": "ManifestResourceTest", "test_file_path": "test/AsmResolver.DotNet.Tests/ManifestResourceTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.Builder;\r\nusing AsmResolver.DotNet.Cloning;\r\nusing AsmResolver.DotNet.Signatures;\r\nusing AsmResolver.DotNet.TestCases.NestedClasses;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables.Rows;\r\nusing AsmResolver.PE.Win32Resources;\r\nusing Xunit;\r\nusing FileAttributes = AsmResolver.PE.DotNet.Metadata.Tables.Rows.FileAttributes;\r\n\r\nnamespace AsmResolver.DotNet.Tests\r\n{\r\n    public class ModuleDefinitionTest\r\n    {\r\n        private static ModuleDefinition Rebuild(ModuleDefinition module)\r\n        {\r\n            using var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            return ModuleDefinition.FromReader(new ByteArrayReader(stream.ToArray()));\r\n        }\r\n        \r\n        [Fact]\r\n        public void ReadNameTest()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            Assert.Equal(\"HelloWorld.exe\", module.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void NameIsPersistentAfterRebuild()\r\n        {\r\n            const string newName = \"HelloMars.exe\";\r\n            \r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            module.Name = newName;\r\n\r\n            var newModule = Rebuild(module);\r\n            Assert.Equal(newName, newModule.Name);\r\n        }\r\n        \r\n        [Fact]\r\n        public void ReadManifestModule()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            Assert.NotNull(module.Assembly);\r\n            Assert.Same(module, module.Assembly.ManifestModule);\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadTypesNoNested()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            Assert.Equal(new[] {\"<Module>\", \"Program\"}, module.TopLevelTypes.Select(t => t.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadTypesNested()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(TopLevelClass1).Assembly.Location);\r\n            Assert.Equal(new HashSet<string>\r\n            {\r\n                \"<Module>\",\r\n                nameof(TopLevelClass1),\r\n                nameof(TopLevelClass2)\r\n            }, module.TopLevelTypes.Select(t => t.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadMaliciousNestedClassLoop()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld_MaliciousNestedClassLoop);\r\n            Assert.Equal(new[] {\"<Module>\", \"Program\"}, module.TopLevelTypes.Select(t => t.Name));\r\n        }\r\n\r\n        [Fact]\r\n        public void ReadMaliciousNestedClassLoop2()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld_MaliciousNestedClassLoop2);\r\n            Assert.Equal(\r\n                new HashSet<string> {\"<Module>\", \"Program\", \"MaliciousEnclosingClass\"},\r\n                new HashSet<string>(module.TopLevelTypes.Select(t => t.Name)));\r\n\r\n            var enclosingClass = module.TopLevelTypes.First(x => x.Name == \"MaliciousEnclosingClass\");\r\n            Assert.Single(enclosingClass.NestedTypes);\r\n            Assert.Single(enclosingClass.NestedTypes[0].NestedTypes);\r\n            Assert.Empty(enclosingClass.NestedTypes[0].NestedTypes[0].NestedTypes);\r\n        }\r\n        \r\n        [Fact]\r\n        public void HelloWorldReadAssemblyReferences()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            Assert.Single(module.AssemblyReferences);\r\n            Assert.Equal(\"mscorlib\", module.AssemblyReferences[0].Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void LookupTypeReference()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            var member = module.LookupMember(new MetadataToken(TableIndex.TypeRef, 12));\r\n            Assert.IsAssignableFrom<TypeReference>(member);\r\n\r\n            var typeRef = (TypeReference) member;\r\n            Assert.Equal(\"System\", typeRef.Namespace);\r\n            Assert.Equal(\"Object\", typeRef.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void LookupTypeDefinition()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            var member = module.LookupMember(new MetadataToken(TableIndex.TypeDef, 2));\r\n            Assert.IsAssignableFrom<TypeDefinition>(member);\r\n            \r\n            var typeDef = (TypeDefinition) member;\r\n            Assert.Equal(\"HelloWorld\", typeDef.Namespace);\r\n            Assert.Equal(\"Program\", typeDef.Name);\r\n        }\r\n\r\n        [Fact]\r\n        public void LookupAssemblyReference()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            var member = module.LookupMember(new MetadataToken(TableIndex.AssemblyRef, 1));\r\n            Assert.IsAssignableFrom<AssemblyReference>(member);\r\n            \r\n            var assemblyRef = (AssemblyReference) member;\r\n            Assert.Equal(\"mscorlib\", assemblyRef.Name);\r\n            Assert.Same(module.AssemblyReferences[0], assemblyRef);\r\n        }\r\n\r\n        [Fact]\r\n        public void LookupModuleReference()\r\n        {\r\n            var module = ModuleDefinition.FromFile(Path.Combine(\"Resources\", \"Manifest.exe\"));\r\n            var member = module.LookupMember(new MetadataToken(TableIndex.ModuleRef, 1));\r\n            Assert.IsAssignableFrom<ModuleReference>(member);\r\n\r\n            var moduleRef = (ModuleReference) member;\r\n            Assert.Equal(\"MyModel.netmodule\", moduleRef.Name);\r\n            Assert.Same(module.ModuleReferences[0], moduleRef);\r\n        }\r\n\r\n        [Fact]\r\n        public void EmptyModuleShouldAlwaysContainCorLibReference()\r\n        {\r\n            // Issue #39 (https://github.com/Washi1337/AsmResolver/issues/39)\r\n            \r\n            var module = new ModuleDefinition(\"TestModule\");\r\n            var corLib = module.CorLibTypeFactory.CorLibScope;\r\n            \r\n            using var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            \r\n            var newModule = ModuleDefinition.FromBytes(stream.ToArray());\r\n            var comparer = new SignatureComparer();\r\n            Assert.Contains(newModule.AssemblyReferences, reference => comparer.Equals(corLib, reference));\r\n        }\r\n\r\n        [Fact]\r\n        public void CreateNewCorLibFactory()\r\n        {\r\n            var module = new ModuleDefinition(\"MySampleModule\");\r\n            Assert.NotNull(module.CorLibTypeFactory);\r\n            Assert.NotNull(module.CorLibTypeFactory.CorLibScope);\r\n            Assert.NotNull(module.CorLibTypeFactory.Void);\r\n        }\r\n        \r\n        [Fact]\r\n        public void AddingTypeIsPersistentAfterRebuild()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            \r\n            var newType = new TypeDefinition(\"SomeNamespace\", \"SomeType\", \r\n                TypeAttributes.Class | TypeAttributes.Abstract | TypeAttributes.Sealed);\r\n            module.TopLevelTypes.Add(newType);\r\n\r\n            var newModule = Rebuild(module);\r\n            var comparer = new SignatureComparer();\r\n            Assert.Contains(newModule.TopLevelTypes, t => comparer.Equals(newType, t));\r\n        }\r\n\r\n        [Fact]\r\n        public void NewFW40ModuleShouldAlwaysContainModuleType()\r\n        {\r\n            var module = new ModuleDefinition(\"TestModule\");\r\n            Assert.NotNull(module.GetModuleType());\r\n        }\r\n\r\n        [Fact]\r\n        public void NewModuleShouldAlwaysContainModuleType()\r\n        {\r\n            var module = new ModuleDefinition(\"TestModule\", KnownCorLibs.NetStandard_v2_1_0_0);\r\n            Assert.NotNull(module.GetModuleType());\r\n        }\r\n\r\n        [Fact]\r\n        public void GetOrCreateModuleConstructorShouldAddNewConstructorIfNotPresent()\r\n        {\r\n            var module = new ModuleDefinition(\"TestModule\", KnownCorLibs.NetStandard_v2_1_0_0);\r\n            var cctor = module.GetOrCreateModuleConstructor();\r\n            Assert.Contains(cctor, module.GetModuleType().Methods);\r\n        }\r\n\r\n        [Fact]\r\n        public void GetOrCreateModuleConstructorShouldGetExistingConstructorIfPresent()\r\n        {\r\n            var module = new ModuleDefinition(\"TestModule\", KnownCorLibs.NetStandard_v2_1_0_0);\r\n            var cctor = module.GetOrCreateModuleConstructor();\r\n            var cctor2 = module.GetOrCreateModuleConstructor();\r\n            Assert.Same(cctor, cctor2);\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentResources()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            \r\n            // Add new directory.\r\n            const string directoryName = \"Test\";\r\n            var entryData = new byte[] {0, 1, 2, 3, 4};\r\n            var directory = new ResourceDirectory(directoryName)\r\n            {\r\n                Entries =\r\n                {\r\n                    new ResourceDirectory(1)\r\n                    {\r\n                        Entries = {new ResourceData(1234, new DataSegment(entryData))}\r\n                    }\r\n                }\r\n            };\r\n            module.NativeResourceDirectory.Entries.Add(directory);\r\n\r\n            // Write and rebuild.\r\n            using var stream = new MemoryStream();\r\n            module.Write(stream);\r\n            var newModule = ModuleDefinition.FromReader(new ByteArrayReader(stream.ToArray()));\r\n\r\n            // Assert contents.\r\n            var newDirectory = (IResourceDirectory) newModule.NativeResourceDirectory.Entries\r\n                .First(entry => entry.Name == directoryName);\r\n            newDirectory = (IResourceDirectory) newDirectory.Entries[0];\r\n            \r\n            var newData = (IResourceData) newDirectory.Entries[0];\r\n            var newContents = (IReadableSegment) newData.Contents;\r\n            Assert.Equal(entryData, newContents.ToArray());\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentTimeStamp()\r\n        {\r\n            var time = new DateTime(2020, 1, 2, 18, 30, 34);\r\n            \r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld);\r\n            module.TimeDateStamp = time;\r\n\r\n            var image = module.ToPEImage();\r\n            Assert.Equal(time, image.TimeDateStamp);\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentExportedType()\r\n        {\r\n            var module = new ModuleDefinition(\"SomeModule.exe\");\r\n\r\n            var assembly = new AssemblyReference(\"SomeAssembly\", new Version(1, 0, 0, 0));\r\n            var type = new ExportedType(assembly, \"SomeNamespace\", \"SomeType\");\r\n\r\n            module.AssemblyReferences.Add(assembly);\r\n            module.ExportedTypes.Add(type);\r\n\r\n            var newModule = Rebuild(module);\r\n            var newType = Assert.Single(newModule.ExportedTypes);\r\n            Assert.Equal(type, newType, new SignatureComparer());\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentFileReferences()\r\n        {\r\n            var module = new ModuleDefinition(\"SomeModule.exe\");\r\n\r\n            var file = new FileReference(\"SubModule.netmodule\", FileAttributes.ContainsMetadata);\r\n\r\n            module.FileReferences.Add(file);\r\n\r\n            var newModule = Rebuild(module);\r\n            var newFile = Assert.Single(newModule.FileReferences);\r\n            Assert.NotNull(newFile);\r\n            Assert.Equal(file.Name, newFile.Name);\r\n        }\r\n    }\r\n}", "test_imports": ["using System;", "using System.Collections.Generic;", "using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.Builder;", "using AsmResolver.DotNet.Cloning;", "using AsmResolver.DotNet.Signatures;", "using AsmResolver.DotNet.TestCases.NestedClasses;", "using AsmResolver.PE.DotNet.Metadata.Tables;", "using AsmResolver.PE.DotNet.Metadata.Tables.Rows;", "using AsmResolver.PE.Win32Resources;", "using Xunit;", "using FileAttributes = AsmResolver.PE.DotNet.Metadata.Tables.Rows.FileAttributes;"], "test_namespace": "AsmResolver.DotNet.Tests", "test_class_name": "ModuleDefinitionTest", "test_file_path": "test/AsmResolver.DotNet.Tests/ModuleDefinitionTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.Signatures;\r\nusing AsmResolver.PE.DotNet.Cil;\r\nusing Xunit;\r\n\r\nnamespace AsmResolver.DotNet.Tests.Signatures\r\n{\r\n    public class MethodSignatureTest\r\n    {\r\n        private readonly ModuleDefinition _module;\r\n\r\n        public MethodSignatureTest()\r\n        {\r\n            _module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld, TestReaderParameters);\r\n        }\r\n\r\n        [Fact]\r\n        public void MakeInstanceShouldHaveHasThisFlagSet()\r\n        {\r\n            var signature = MethodSignature.CreateInstance(_module.CorLibTypeFactory.Void);\r\n            Assert.True(signature.HasThis);\r\n            Assert.False(signature.IsGeneric);\r\n        }\r\n\r\n        [Fact]\r\n        public void MakeStaticShouldNotHaveHasThisFlagSet()\r\n        {\r\n            var signature = MethodSignature.CreateStatic(_module.CorLibTypeFactory.Void);\r\n            Assert.False(signature.HasThis);\r\n            Assert.False(signature.IsGeneric);\r\n        }\r\n\r\n        [Fact]\r\n        public void MakeGenericInstanceShouldHaveHasThisAndGenericFlagSet()\r\n        {\r\n            var signature = MethodSignature.CreateInstance(_module.CorLibTypeFactory.Void, 1);\r\n            Assert.True(signature.HasThis);\r\n            Assert.True(signature.IsGeneric);\r\n        }\r\n\r\n        [Fact]\r\n        public void MakeGenericStaticShouldNotHaveHasThisAndGenericFlagSet()\r\n        {\r\n            var signature = MethodSignature.CreateStatic(_module.CorLibTypeFactory.Void, 1);\r\n            Assert.False(signature.HasThis);\r\n            Assert.True(signature.IsGeneric);\r\n        }\r\n\r\n        [Theory]\r\n        [InlineData(false)]\r\n        [InlineData(true)]\r\n        public void SentinelParameterTypes(bool rebuild)\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.ArgListTest, TestReaderParameters);\r\n            if (rebuild)\r\n            {\r\n                using var stream = new MemoryStream();\r\n                module.Write(stream);\r\n                module = ModuleDefinition.FromBytes(stream.ToArray(), TestReaderParameters);\r\n            }\r\n\r\n            var reference = (MemberReference) module.ManagedEntryPointMethod!.CilMethodBody!\r\n                .Instructions.First(i => i.OpCode.Code == CilCode.Call)\r\n                .Operand!;\r\n\r\n            var signature = Assert.IsAssignableFrom<MethodSignature>(reference.Signature);\r\n            var type = Assert.Single(signature.SentinelParameterTypes);\r\n\r\n            Assert.Equal(module.CorLibTypeFactory.String, type, SignatureComparer.Default);\r\n        }\r\n    }\r\n}\r\n", "test_imports": ["using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.Signatures;", "using AsmResolver.PE.DotNet.Cil;", "using Xunit;"], "test_namespace": "AsmResolver.DotNet.Tests.Signatures", "test_class_name": "MethodSignatureTest", "test_file_path": "test/AsmResolver.DotNet.Tests/Signatures/MethodSignatureTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}, {"tests": "using System.IO;\r\nusing System.Linq;\r\nusing AsmResolver.DotNet.Builder;\r\nusing AsmResolver.DotNet.Serialized;\r\nusing AsmResolver.DotNet.Signatures;\r\nusing AsmResolver.DotNet.Signatures.Types;\r\nusing AsmResolver.DotNet.TestCases.Generics;\r\nusing AsmResolver.PE.DotNet.Metadata.Tables;\r\nusing Xunit;\r\n\r\nnamespace AsmResolver.DotNet.Tests\r\n{\r\n    public class TypeSpecificationTest\r\n    {\r\n        \r\n        [Fact]\r\n        public void ReadGenericTypeInstantiation()\r\n        {\r\n            var module = ModuleDefinition.FromFile(typeof(GenericsTestClass).Assembly.Location);\r\n            var fieldType = module\r\n                .TopLevelTypes.First(t => t.Name == nameof(GenericsTestClass))\r\n                .Fields.First(f => f.Name == nameof(GenericsTestClass.GenericField))\r\n                .Signature.FieldType;\r\n\r\n            Assert.IsAssignableFrom<GenericInstanceTypeSignature>(fieldType);\r\n            var genericType = (GenericInstanceTypeSignature) fieldType;\r\n            Assert.Equal(\"GenericType`3\", genericType.GenericType.Name);\r\n            Assert.Equal(new[]\r\n            {\r\n                \"System.String\", \"System.Int32\", \"System.Object\"\r\n            }, genericType.TypeArguments.Select(a => a.FullName));\r\n        }\r\n\r\n        [Fact]\r\n        public void PersistentGenericTypeInstantiation()\r\n        {  \r\n            var module = ModuleDefinition.FromFile(typeof(GenericsTestClass).Assembly.Location);\r\n            \r\n            using var tempStream = new MemoryStream();\r\n            module.Write(tempStream);\r\n            \r\n            module = ModuleDefinition.FromBytes(tempStream.ToArray());\r\n            var fieldType = module\r\n                .TopLevelTypes.First(t => t.Name == nameof(GenericsTestClass))\r\n                .Fields.First(f => f.Name == nameof(GenericsTestClass.GenericField))\r\n                .Signature.FieldType;\r\n\r\n            Assert.IsAssignableFrom<GenericInstanceTypeSignature>(fieldType);\r\n            var genericType = (GenericInstanceTypeSignature) fieldType;\r\n            Assert.Equal(\"GenericType`3\", genericType.GenericType.Name);\r\n            Assert.Equal(new[]\r\n            {\r\n                \"System.String\", \"System.Int32\", \"System.Object\"\r\n            }, genericType.TypeArguments.Select(a => a.FullName));\r\n        }\r\n        \r\n        [Fact]\r\n        public void IllegalTypeSpecInTypeDefOrRef()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld_IllegalTypeSpecInTypeDefOrRefSig);\r\n            var typeSpec =  (TypeSpecification) module.LookupMember(new MetadataToken(TableIndex.TypeSpec, 1));\r\n            Assert.NotNull(typeSpec);\r\n        }\r\n        \r\n        [Fact]\r\n        public void MaliciousTypeSpecLoop()\r\n        {\r\n            var module = ModuleDefinition.FromBytes(Properties.Resources.HelloWorld_MaliciousTypeSpecLoop,\r\n                new ModuleReaderParameters(EmptyErrorListener.Instance));\r\n            var typeSpec =  (TypeSpecification) module.LookupMember(new MetadataToken(TableIndex.TypeSpec, 1));\r\n            Assert.NotNull(typeSpec.Signature);\r\n        }\r\n        \r\n    }\r\n}", "test_imports": ["using System.IO;", "using System.Linq;", "using AsmResolver.DotNet.Builder;", "using AsmResolver.DotNet.Serialized;", "using AsmResolver.DotNet.Signatures;", "using AsmResolver.DotNet.Signatures.Types;", "using AsmResolver.DotNet.TestCases.Generics;", "using AsmResolver.PE.DotNet.Metadata.Tables;", "using Xunit;"], "test_namespace": "AsmResolver.DotNet.Tests", "test_class_name": "TypeSpecificationTest", "test_file_path": "test/AsmResolver.DotNet.Tests/TypeSpecificationTest.cs", "test_runner": "xUnit", "project_path": "test/AsmResolver.DotNet.Tests/AsmResolver.DotNet.Tests.csproj"}], "results": {}, "response": {"response": {"id": "chatcmpl-AxG84K5EnS3t67Wb305D16W3AhEoS", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "```csharp\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    var filePath = \"TestModule.dll\";\n    \n    // Act\n    moduleDefinition.Write(filePath);\n    \n    // Assert\n    Assert.True(File.Exists(filePath));\n    File.Delete(filePath); // Clean up after test\n}\n\n[Fact]\npublic void Write_Test_2_With_ImageBuilder()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    var filePath = \"TestModule.dll\";\n    var imageBuilder = new ManagedPEImageBuilder(); // Assuming a default constructor exists\n\n    // Act\n    moduleDefinition.Write(filePath, imageBuilder);\n\n    // Assert\n    Assert.True(File.Exists(filePath));\n    File.Delete(filePath); // Clean up after test\n}\n\n[Fact]\npublic void Write_Test_3_With_OutputStream()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    using var memoryStream = new MemoryStream();\n    var imageBuilder = new ManagedPEImageBuilder(); // Assuming a default constructor exists\n\n    // Act\n    moduleDefinition.Write(memoryStream, imageBuilder);\n\n    // Assert\n    Assert.True(memoryStream.Length > 0);\n}\n\n[Fact]\npublic void Write_Test_4_With_FileBuilder()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    var filePath = \"TestModule.dll\";\n    var imageBuilder = new ManagedPEImageBuilder(); // Assuming a default constructor exists\n    var fileBuilder = new PEFileBuilder(); // Assuming a default constructor exists\n\n    // Act\n    moduleDefinition.Write(filePath, imageBuilder, fileBuilder);\n\n    // Assert\n    Assert.True(File.Exists(filePath));\n    File.Delete(filePath); // Clean up after test\n}\n\n[Fact]\npublic void Write_Test_5_With_Stream_FileBuilder()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    using var memoryStream = new MemoryStream();\n    var imageBuilder = new ManagedPEImageBuilder(); // Assuming a default constructor exists\n    var fileBuilder = new PEFileBuilder(); // Assuming a default constructor exists\n\n    // Act\n    moduleDefinition.Write(memoryStream, imageBuilder, fileBuilder);\n\n    // Assert\n    Assert.True(memoryStream.Length > 0);\n}\n\n[Fact]\npublic void Write_Test_6_With_BinaryStreamWriter()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    using var memoryStream = new MemoryStream();\n    var writer = new BinaryStreamWriter(memoryStream); // Assuming a constructor exists\n    var imageBuilder = new ManagedPEImageBuilder(); // Assuming a default constructor exists\n    var fileBuilder = new PEFileBuilder(); // Assuming a default constructor exists\n\n    // Act\n    moduleDefinition.Write(writer, imageBuilder, fileBuilder);\n\n    // Assert\n    Assert.True(memoryStream.Length > 0);\n}\n\n[Fact]\npublic void Write_Test_7_Throws_AggregateException()\n{\n    // Arrange\n    var moduleDefinition = new ModuleDefinition(\"TestModule\");\n    var invalidFilePath = \"\"; // Invalid path to trigger exception\n\n    // Act & Assert\n    Assert.Throws<AggregateException>(() => moduleDefinition.Write(invalidFilePath));\n}\n```\n", "role": "assistant", "function_call": null, "tool_calls": null, "refusal": null}}], "created": 1738686716, "model": "gpt-4o-mini-2024-07-18", "object": "chat.completion", "system_fingerprint": "fp_bd83329f63", "usage": {"completion_tokens": 675, "prompt_tokens": 4961, "total_tokens": 5636, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default"}, "imports": {"id": "chatcmpl-AxG8T6agjS1ggpW4lLqPFmXETwQQL", "choices": [{"finish_reason": "stop", "index": 0, "logprobs": null, "message": {"content": "To run the provided unit tests, you will need the following using directives at the top of your test file:\n\n```csharp\nusing System;\nusing System.IO;\nusing Xunit; // For the Xunit testing framework\nusing AsmResolver.DotNet; // For ModuleDefinition and related classes\nusing AsmResolver.DotNet.Builder; // For ManagedPEImageBuilder and PEFileBuilder\nusing AsmResolver.PE; // For IPEImage and related classes\nusing AsmResolver.PE.DotNet.Metadata; // For metadata-related classes\nusing AsmResolver.PE.DotNet.Metadata.Tables; // For tables related to metadata\n```\n\nMake sure you have the necessary NuGet packages installed for `Xunit` and `AsmResolver` to ensure that all the classes and methods used in the tests are available.", "role": "assistant", "function_call": null, "tool_calls": null, "refusal": null}}], "created": 1738686741, "model": "gpt-4o-mini-2024-07-18", "object": "chat.completion", "system_fingerprint": "fp_bd83329f63", "usage": {"completion_tokens": 165, "prompt_tokens": 5651, "total_tokens": 5816, "prompt_tokens_details": {"cached_tokens": 5504, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default"}}}